<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>给Nuxt使用的基于API的CMS——还有管理后台呢 | Jenny的小站</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="April CMS，一个兼具Headless CMS和Flat File CMS的特征的操作文本文件的基于API提供内容的CMS，很实用的一个项目哦~"><meta data-n-head="ssr" data-hid="keyword" name="keyword" content="中文, 我的项目, JavaScript, Node.js, jQuery, 技术"><link data-n-head="ssr" rel="shortcut icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="/css/font-gugi.css"><link data-n-head="ssr" rel="stylesheet" href="/css/font-poppins.css"><link data-n-head="ssr" rel="stylesheet" href="/css/style.css?2020-04-12"><link data-n-head="ssr" rel="stylesheet" href="/font-awesome/css/font-awesome.min.css"><link data-n-head="ssr" rel="stylesheet" href="/css/github-markdown.min.css"><link data-n-head="ssr" rel="stylesheet" href="/css/hljs.dark.min.css"><link data-n-head="ssr" rel="stylesheet" href="https://hzn-website.000webhostapp.com/disqus/dist/iDisqus.min.css"><script data-n-head="ssr" src="/js/statcounter.js"></script><base href="/"><link rel="preload" href="/_nuxt/0109b093b32bbe681dcb.js" as="script"><link rel="preload" href="/_nuxt/8c2350c4dfed45e215a8.js" as="script"><link rel="preload" href="/_nuxt/c4b816bfcec5991a02bc.js" as="script"><link rel="preload" href="/_nuxt/7c82ebcda90129e59b83.js" as="script"><style data-vue-ssr-id="3191d5ad:0 72520070:0 f28bdea2:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#3b8070;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}#amzn-assoc-ad-51e0e5d0-fdd4-49b3-8945-e3e2f60d21e2{box-shadow:0 0 1px 1px silver}div.amzn-native-product-asin-container:hover{box-shadow:inset 0 0 1px 1px silver}.markdown-body{margin-bottom:50px}.markdown-body img{max-height:100px}a[id]{position:relative;top:-40px;display:block}a#comment-link{top:0}.blog-desc{margin:10px;padding:10px;color:#666;background-color:rgba(0,0,0,.025)}.youtube-img{position:relative;display:inline-block}.youtube-img:before{width:40%;height:40%;border-radius:25%;background:rgba(0,0,0,.7);transition:background .2s}.youtube-img:after,.youtube-img:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.youtube-img:after{width:0;height:0;border-top:10px solid transparent;border-left:20px solid #fff;border-bottom:10px solid transparent}.youtube-img:hover:before{background:red}#disqus_thread{margin-top:20px}.prev-next{margin:20px auto;display:block}.prev-next:after{display:table;content:" ";clear:both}.prev-next a{display:inline}.next,.prev{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin:20px auto;width:100%;color:grey;border:1px solid grey;cursor:pointer}.prev{width:48%;text-align:left;float:left}.next{width:48%;text-align:right;float:right}.next:hover,.prev:hover{color:#000;border-color:#000}.prev p{padding-left:16px}.next p,.prev p{margin:0;padding-top:16px;padding-bottom:16px}.next p{padding-right:16px}#comment{margin-top:40px}.blog-gallery{margin:20px auto;display:flex;justify-content:center;flex-wrap:wrap;overflow:hidden}.blog-gallery-unit{margin:40px 20px 0;width:46%;border:1px solid silver;border-radius:5px}.blog-gallery-unit:first-child,.blog-gallery-unit:nth-child(2){margin-top:20px}.blog-gallery-unit:nth-child(2n-1){margin-left:0}.blog-gallery-unit:nth-child(2n){margin-right:0}.blog-gallery-unit:hover{border-color:#000}.blog-gallery-inner{padding:21px 10px 10px;height:100%}.blog-gallery-inner h4{margin-top:0;max-height:42px;overflow:hidden}.blog-gallery-desc{line-height:21px;max-height:64px;display:block;overflow:hidden}.blog-gallery-tag{margin:1px;padding:0 8px;color:#fff;font-size:12px;font-family:Microsoft Yahei;line-height:20px;border-radius:999px;background:grey;display:inline-block}@media (max-width:425px){.blog-gallery-unit{margin:20px 0 0;width:100%}}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="container"><nav><div class="nav-wrap"><header><a href="/" class="no-decor-link"><p class="nav-home">Jenny's blog</p></a></header> <div class="nav-btn"><div class="bar"></div> <div class="bar"></div> <div class="bar"></div> <div class="bar"></div></div> <div class="nav-mask"></div> <div class="body-mask"></div> <ul class="nav-ul"><span title="Change navigation to English" class="nav-link" style="padding-left:10px">English</span> <a href="/" target="_self" class="nav-link"><li>首页<!----><!----></li></a><a href="/resume" target="_self" class="nav-link"><li>简历<!----><!----></li></a><a href="/portfolio" target="_self" class="nav-link"><li>作品集<!----><!----></li></a><a href="/blog" target="_self" class="nav-link nuxt-link-active"><li>博客<!----><!----></li></a><a href="https://wj.qq.com/s2/3731207/f0cd/" target="_blank" class="nav-link"><li>联系我<span> </span><i class="fa fa-external-link"></i></li></a></ul></div></nav> <main><div><section class="main-content"><h1 class="align-center article-title">给Nuxt使用的基于API的CMS——还有管理后台呢</h1> <p class="blog-date align-center"><span class="fa fa-calendar"> 2020-04-19</span></p> <p class="blog-tags align-center"><a href="/blog/tag/中文"><span class="blog-tag">中文</span></a><a href="/blog/tag/我的项目"><span class="blog-tag">我的项目</span></a><a href="/blog/tag/JavaScript"><span class="blog-tag">JavaScript</span></a><a href="/blog/tag/Node.js"><span class="blog-tag">Node.js</span></a><a href="/blog/tag/jQuery"><span class="blog-tag">jQuery</span></a><a href="/blog/tag/技术"><span class="blog-tag">技术</span></a></p> <div class="blog-desc">April CMS，一个兼具Headless CMS和Flat File CMS的特征的操作文本文件的基于API提供内容的CMS，很实用的一个项目哦~</div> <article class="markdown-body"><p></p><h3> </h3><ul><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#CMS_1">一个真正的CMS</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_21">后端需要实现的效果</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_30">前端需要实现的效果</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_51">后端的实际写法</a></li><ul><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#API__53">API 使用的依赖包</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#API__HTML__Markdown__100">API 被调用时返回处理后的 HTML 或原 Markdown 内容</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_API__235">给 API 添加管理后台入口</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_262">保存文件和删除文件</a></li></ul><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_297">前端的实际写法</a></li><ul><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_API__Markdown_299">调用 API 和渲染 Markdown</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_Markdown__305">渲染 Markdown 时的注意事项</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_349">添加页内平滑滚动效果</a></li></ul><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_377">大概是这么个效果</a></li><li><a href="blog/editor-for-my-cms-of-my-nuxt-blog#_389">心得体会</a></li></ul><p></p>
<h1><a id="CMS_1"></a>一个真正的CMS</h1>
<p>GitHub 项目地址： <a href="https://github.com/c53hzn/april-cms">https://github.com/c53hzn/april-cms</a></p>
<p>去年开始学习使用 <code>Nuxt</code> 的时候，看了很多关于 <code>Headless CMS</code> 的介绍，按我的理解，就是 <code>不带前端页面设计的内容管理系统</code> ，研究了一下这类的项目以及相关使用方法，自己也尝试使用了一下，但是没有坚持到底，还是想不依赖这些外部服务来构建自己的网站。不过评论系统和访客统计还是得用外部服务，因为静态网站服务器做不到这些。</p>
<p>后来我自己写出了可以用作 <code>CMS</code> 的 <code>API</code>，可以参见 <a href="/blog/nuxt-blog-static-website">如何使用Nuxt建立个人博客</a>。</p>
<p>这个 <code>API</code> 让我可以只需更新 <code>Markdown</code> 文章，再使用 <code>Nuxt</code> 的生成静态页面的功能就可以更新我的网站。通常我是用 <code>Sublime Text</code> 这个编辑器来编写代码的，它可以在左边显示工程文件，切换起来也挺方便的。</p>
<blockquote>
<p>可是人类就是喜欢自找麻烦。</p>
<p>by 我</p>
</blockquote>
<p>我想要一个有界面的 <code>CMS</code>，能新建，能修改，能读取，能保存，能删除。但是我只要操作 <code>Markdown</code> 文件，而不要任何数据库。</p>
<p>我觉得我能做到。</p>
<p>写了个英文版 <a href="/blog/editor-for-my-cms-of-my-nuxt-blog-en">Write a control panel for my API-based CMS for Nuxt</a>，大家随便看看就好。</p>
<h1><a id="_21"></a>后端需要实现的效果</h1>
<p>由于我原本的 <code>API</code> 是用 <code>Node</code> 的 <code>express</code> 写的，所以还是想在此基础上继续精进，那么就需要掌握 <code>Node</code> 服务器的一些用法，比如：</p>
<ol>
<li>让 <code>API</code> 读取静态 HTML 页面，使浏览器能显示 <code>CMS</code> 的 UI 界面。</li>
<li>开启 <code>API</code> 的时候自动打开浏览器访问入口，也就是前一项的 UI 界面。</li>
<li>让 <code>API</code> 能接受浏览器（客户端）传回来的数据，并保存到本地。</li>
<li>让 <code>API</code> 接受浏览器传回来的数据，然后删除相关文件。</li>
</ol>
<h1><a id="_30"></a>前端需要实现的效果</h1>
<p>我之前还有一个在 <a href="https://www.codepen.io">CodePen</a> 上的 <a href="https://codepen.io/c53hzn/full/YzzRzxR">Markdown Previewer</a> 的项目，半年来浏览量一只手就能数得清，就这么放着也挺可惜，不如拿来这里用一用。</p>
<p>CodePen 项目的渲染效果是用 <code>marked</code> 来实现的的，而我的 <code>API</code> 里面是用 <code>markdown-it</code> 来做渲染的，为了统一写法，得把渲染的方式改成 <code>Markdown-it</code>。</p>
<p>这个项目主体是用 <code>jQuery</code> 写的，我最终决定继续用 <code>jQuery</code> 来写前端的页面交互。</p>
<p>那么我们就需要解决以下的问题：</p>
<ol>
<li>读取 <code>API</code> 传来的文章列表并渲染到文章列表区</li>
<li>读取 <code>API</code> 传来的文章内容并渲染文章的标题、标签、描述、关联文章、正文到各个输入框，以及最重要的 <code>Markdown</code> 编辑器</li>
<li>每当 <code>Markdown</code> 编辑器有更新时，预览区也要跟着更新，预览区还应该有代码高亮和一般样式渲染</li>
<li>点击 <code>Save post</code> 的时候，页面要检查各个输入框是否都有内容，没有则 <code>alert</code> 让填写内容，有的话再检查文章是否已存在，存在则 <code>confirm</code> 要不要更新，不存在则 <code>confirm</code> 要不要创建。</li>
<li>点击 <code>Delete post</code> 的时候，页面要检查 <code>slug</code> 在文章列表里是否存在，不存在则 <code>alert</code> 说没东西可删，如果存在则要 <code>confirm</code> 是否真的删除。</li>
<li>键盘按下 <code>ctrl+enter</code> 触发保存，效果等同于点击 <code>Save post</code>。</li>
<li>当确认要更新或创建的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交内容到服务器，并获取提交结果，反映到浏览器</li>
<li>当确认要删除的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交要删除的 <code>slug</code> 到服务器，并获取删除结果，反映到浏览器。</li>
</ol>
<p>并且这些要在一个页面里完成。</p>
<h1><a id="_51"></a>后端的实际写法</h1>
<h2><a id="API__53"></a>API 使用的依赖包</h2>
<p>先 <code>require</code> 一下各个依赖。</p>
<pre class="hljs"><code class="language-javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">var</span> fm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'front-matter'</span>);
<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highlight.js'</span>);
<span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it'</span>);
<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it-toc'</span>);
<span class="hljs-keyword">var</span> open = <span class="hljs-built_in">require</span>(<span class="hljs-string">"open"</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(__dirname+<span class="hljs-string">"\\config.js"</span>);
<span class="hljs-keyword">var</span> app = express();
<span class="hljs-keyword">var</span> md = markdownIt({
  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 在源码中启用 HTML 标签</span>
  xhtmlOut:     <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 使用 '/' 来闭合单标签 （比如 &lt;br />）。</span>
  breaks:       <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 转换段落里的 '\n' 到 &lt;br>。</span>
  langPrefix:   <span class="hljs-string">'language-'</span>,  <span class="hljs-comment">// 给围栏代码块的 CSS 语言前缀。对于额外的高亮代码非常有用。</span>
  linkify:      <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 将类似 URL 的文本自动转换为链接。</span>
  typographer:  <span class="hljs-literal">false</span>,
  <span class="hljs-attr">quotes</span>: <span class="hljs-string">'“”‘’'</span>,
  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{
    <span class="hljs-keyword">if</span> (lang && hljs.getLanguage(lang)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;
      } <span class="hljs-keyword">catch</span> (__) {}
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>; <span class="hljs-comment">// 使用额外的默认转义</span>
  }
});
md.use(markdownItToc);
</code></pre>
<p>这里有个 <code>config</code> 是我额外加的配置文件，里面的内容也很简单</p>
<pre class="hljs"><code class="language-javascript"><span class="hljs-keyword">var</span> config = {
	<span class="hljs-attr">isSlugUseDate</span>: <span class="hljs-literal">false</span>,
	<span class="hljs-attr">blogPath</span>: __dirname + <span class="hljs-string">'\\blog'</span>,
	<span class="hljs-attr">imgPath</span>: __dirname + <span class="hljs-string">'\\img\\blog'</span>
};
<span class="hljs-built_in">module</span>.exports = config;
</code></pre>
<p>这个 <code>config</code> 是为了控制 <code>CMS</code> 里面的 <code>Markdown</code> 文件和图片文件的路径，以及 <code>API</code> 返回的 <code>slug</code> 是否使用日期而加的。如果 <code>slug</code> 使用日期，就会是一个长的 <code>slug</code>，比如 <code>2020-04-19-editor-for-my-cms-of-my-nuxt-blog</code>，如果不使用日期，就会是一个短的 <code>slug</code>，比如 <code>editor-for-my-cms-of-my-nuxt-blog</code>，那么相应的，博客文章的 <code>URL</code> 也会有长短之分，就看大家自己喜欢哪一种了。</p>
<h2><a id="API__HTML__Markdown__100"></a>API 被调用时返回处理后的 HTML 或原 Markdown 内容</h2>
<p>在 <code>API</code> 的入口文件 <code>app.js</code> 里面做一下配置，这样就可以控制返回的文章正文是 <code>Markdown</code> 还是经过处理的 <code>HTML</code> 内容，同时 <code>API</code> 也会按照 <code>config</code> 里面对 <code>slug</code> 的要求，根据所请求的 <code>slug</code> 返回内容。</p>
<pre class="hljs"><code class="language-JavaScript"><span class="hljs-keyword">var</span> slugToFileName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">slug,isSlugUseDate</span>) </span>{
  <span class="hljs-keyword">var</span> result = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">if</span> (isSlugUseDate) {
    result = slug+<span class="hljs-string">".md"</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> files = fs.readdirSync(config.blogPath);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
      <span class="hljs-keyword">let</span> tempSlug = files[i].substring(<span class="hljs-number">11</span>,files[i].length);
      <span class="hljs-keyword">if</span> (tempSlug == slug+<span class="hljs-string">".md"</span>) {
        result = files[i];
        <span class="hljs-keyword">break</span>;
      }
    }
  }
  <span class="hljs-keyword">return</span> result;
}
<span class="hljs-keyword">var</span> fileNameToSlug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename,isSlugUseDate</span>) </span>{
  <span class="hljs-keyword">if</span> (isSlugUseDate) {
    <span class="hljs-keyword">return</span> filename.substring(<span class="hljs-number">0</span>,filename.length<span class="hljs-number">-3</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> filename.substring(<span class="hljs-number">11</span>,filename.length<span class="hljs-number">-3</span>);
  }
}
<span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath,slug,isContentRequired,isMD,isDev</span>) </span>{
  <span class="hljs-keyword">var</span> blog = {};
  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));
  blog = content.attributes;
  blog.slug = slug;
  <span class="hljs-keyword">var</span> fullFilename = fullPath.replace(config.blogPath+<span class="hljs-string">"\\"</span>,<span class="hljs-string">""</span>);
  blog.date = fullFilename.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);
  <span class="hljs-keyword">if</span> (isContentRequired && !isMD) {
    <span class="hljs-keyword">let</span> html = md.render(<span class="hljs-string">'@[toc]( )\n'</span> + content.body);
    <span class="hljs-comment">//if isDev then use absolute path for images</span>
    <span class="hljs-keyword">if</span> (isDev) {
      html = html.replace(<span class="hljs-regexp">/src=\"(\/)?img/g</span>,<span class="hljs-string">"src=\"http://127.0.0.1:4000/img"</span>);
    }
    <span class="hljs-comment">// add class "hljs" for dark theme rendering</span>
    blog.content = html.replace(<span class="hljs-regexp">/\&lt;pre/g</span>,<span class="hljs-string">"&lt;pre class='hljs'"</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isContentRequired && isMD) {
    blog.content = content.body;
  }
  <span class="hljs-keyword">return</span> blog;
}
<span class="hljs-comment">//return blog related contents</span>
app.get(<span class="hljs-string">"/blog"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// allow cross orign access</span>
  res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
  <span class="hljs-keyword">var</span> blogPath = config.blogPath;
  <span class="hljs-keyword">var</span> imgPath = config.imgPath;
  <span class="hljs-keyword">var</span> files = fs.readdirSync(blogPath);
  <span class="hljs-keyword">var</span> json = {};<span class="hljs-comment">// result to be returned</span>
  <span class="hljs-keyword">var</span> qSlug = req.query.slug || <span class="hljs-string">""</span>;
  <span class="hljs-keyword">var</span> qTag = req.query.tag || <span class="hljs-string">""</span>;
  <span class="hljs-keyword">var</span> qImg = req.query.img || <span class="hljs-string">""</span>;
  <span class="hljs-keyword">var</span> qIsMD = req.query.ismd == <span class="hljs-string">"true"</span>;
  <span class="hljs-keyword">var</span> qIsDev = req.query.isdev == <span class="hljs-string">"true"</span>;
  <span class="hljs-keyword">var</span> isSlugUseDate = (req.query.iseditor == <span class="hljs-string">"true"</span>)?<span class="hljs-literal">true</span>:config.isSlugUseDate;
  <span class="hljs-keyword">if</span> (qSlug) {<span class="hljs-comment">// with blog slug query</span>
    json = singleBlog(<span class="hljs-string">`<span class="hljs-subst">${blogPath}</span>\\<span class="hljs-subst">${slugToFileName(qSlug,isSlugUseDate)}</span>`</span>,qSlug,<span class="hljs-literal">true</span>,qIsMD,qIsDev);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; files.length; k++) {<span class="hljs-comment">// add prev and next blog</span>
      <span class="hljs-keyword">if</span> (qSlug == fileNameToSlug(files[k],isSlugUseDate)) {
        <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) {
          json.next = fileNameToSlug(files[k+<span class="hljs-number">1</span>],isSlugUseDate);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k === files.length<span class="hljs-number">-1</span>) {
          json.prev = fileNameToSlug(files[k<span class="hljs-number">-1</span>],isSlugUseDate);
        } <span class="hljs-keyword">else</span> {
          json.prev = fileNameToSlug(files[k<span class="hljs-number">-1</span>],isSlugUseDate);
          json.next = fileNameToSlug(files[k+<span class="hljs-number">1</span>],isSlugUseDate);
        }
      }
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qTag) {<span class="hljs-comment">// with tag query</span>
    <span class="hljs-keyword">if</span> (qTag == <span class="hljs-string">"all_tags"</span>) {<span class="hljs-comment">// returns list of all available tags</span>
      json.tags = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
        <span class="hljs-keyword">let</span> blogPost = singleBlog(blogPath+<span class="hljs-string">"\\"</span>+files[i],fileNameToSlug(files[i],isSlugUseDate));
        <span class="hljs-keyword">let</span> tags = blogPost.tags || [<span class="hljs-string">'none'</span>];
        <span class="hljs-keyword">let</span> entry = {
          <span class="hljs-attr">title</span>: blogPost.title,
          <span class="hljs-attr">slug</span>: blogPost.slug
        };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {
          <span class="hljs-keyword">if</span> (json.tags[tags[j]]) {
            json.tags[tags[j]]++;
          } <span class="hljs-keyword">else</span> {
            json.tags[tags[j]] = <span class="hljs-number">1</span>;
          }
        }
      }
    } <span class="hljs-keyword">else</span> {<span class="hljs-comment">// returns blog list of specific tag</span>
      json.blogs = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
        <span class="hljs-keyword">let</span> blogPost = singleBlog(blogPath+<span class="hljs-string">"\\"</span>+files[i],fileNameToSlug(files[i],isSlugUseDate));
        <span class="hljs-keyword">let</span> tags = blogPost.tags || [<span class="hljs-string">'none'</span>];
        <span class="hljs-keyword">let</span> entry = {
          <span class="hljs-attr">title</span>: blogPost.title,
          <span class="hljs-attr">slug</span>: blogPost.slug
        };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {
          <span class="hljs-keyword">if</span> (tags[j] == qTag) {
            json.blogs.unshift(blogPost);
          }
        }
      }
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qImg) {<span class="hljs-comment">// with img query</span>
    <span class="hljs-keyword">if</span> (qImg == <span class="hljs-string">"all_imgs"</span>) {
      json.imgs = {};
      <span class="hljs-keyword">var</span> imgFolders = fs.readdirSync(imgPath);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgFolders.length; i++) {
        <span class="hljs-keyword">let</span> imgs = fs.readdirSync(imgPath+<span class="hljs-string">"\\"</span>+imgFolders[i]);
        json.imgs[imgFolders[i]] = imgs;
      }
    }
  } <span class="hljs-keyword">else</span> {<span class="hljs-comment">//without requirement, returns list of all blogs</span>
    json.blogs = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
      <span class="hljs-keyword">let</span> blogPost = singleBlog(blogPath+<span class="hljs-string">"\\"</span>+files[i],fileNameToSlug(files[i],isSlugUseDate));
      json.blogs.unshift(blogPost);
    }
  }
  res.send(json);
});
app.get(<span class="hljs-string">"/config"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// allow cross orign access</span>
  res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
  res.send(config);
});
</code></pre>
<h2><a id="_API__235"></a>给 API 添加管理后台入口</h2>
<p>我在 <code>API</code> 所在的文件夹新建了 <code>app.html</code>，以作为 UI 界面的入口，而要让 <code>API</code> 可以访问这个静态页面，就要像下面这样写</p>
<pre class="hljs"><code class="language-JavaScript"><span class="hljs-comment">//return blog content editor page</span>
app.use(express.static(__dirname));
app.get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    <span class="hljs-comment">// allow cross orign access</span>
  res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
  res.sendFile(__dirname+<span class="hljs-string">"\\app.html"</span>);
});
<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>
app.listen(<span class="hljs-number">4000</span>, () => {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)
});
</code></pre>
<p>那么这个 <code>CMS</code> 的入口链接就是 <code>http://127.0.0.1:4000/</code> 了。</p>
<p>为了能在开启 <code>API</code> 的时候自动打开浏览器并访问该地址，还需要使用 <code>open</code> 这个 <code>npm</code>，然后加一行打开浏览器的指令</p>
<pre class="hljs"><code class="language-JavaScript">open(<span class="hljs-string">"http:127.0.0.1:4000/"</span>,{<span class="hljs-attr">app</span>: <span class="hljs-string">"chrome.exe"</span>});
</code></pre>
<p>就能直接自动打开浏览器并访问 <code>CMS</code> 的管理界面了。这个界面总共也就一页，所以很好管理。</p>
<h2><a id="_262"></a>保存文件和删除文件</h2>
<p>之后就是接受浏览器传回来的数据并保存到本地，或者接收浏览器传回的删除指令，删除相关文件。</p>
<pre class="hljs"><code class="language-JavaScript"><span class="hljs-comment">//api to submit post</span>
<span class="hljs-comment">// Parse URL-encoded bodies (as sent by HTML forms)</span>
app.use(express.urlencoded({ <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));
<span class="hljs-comment">// Parse JSON bodies (as sent by API clients)</span>
app.use(express.json());
<span class="hljs-comment">// Access the parse results as request.body</span>
app.post(<span class="hljs-string">'/savepost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
  <span class="hljs-keyword">var</span> obj = req.body;
  <span class="hljs-keyword">var</span> fileName = config.blogPath+<span class="hljs-string">"\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;
    fs.writeFileSync(fileName, obj.str);
    <span class="hljs-comment">//Client will get status of failure w/o this</span>
    <span class="hljs-comment">//even if data is saved to server successfully</span>
    res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});
});
<span class="hljs-comment">// delete post</span>
app.post(<span class="hljs-string">'/deletepost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
  <span class="hljs-keyword">var</span> obj = req.body;
  <span class="hljs-keyword">var</span> fileName = config.blogPath+<span class="hljs-string">"\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;
  <span class="hljs-keyword">try</span> {
    fs.unlinkSync(fileName);
    <span class="hljs-comment">//file removed</span>
  } <span class="hljs-keyword">catch</span>(err) {
    <span class="hljs-built_in">console</span>.error(err);
  }
    <span class="hljs-comment">//Client will get status of failure w/o this</span>
    <span class="hljs-comment">//even if data is saved to server successfully</span>
    res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});
});
</code></pre>
<h1><a id="_297"></a>前端的实际写法</h1>
<h2><a id="_API__Markdown_299"></a>调用 API 和渲染 Markdown</h2>
<p>具体代码其实没什么好说的，文章列表的 <code>API</code> 是 <code>/blogs</code>，而保存文章的 <code>API</code> 是 <code>/savepost</code>，删除文章的 <code>API</code> 是 <code>/deletepost</code>，获取文章列表可以用 <code>jQuery</code> 的 <code>getJSON</code> 方法，而保存和删除可以用 <code>jQuery</code> 的 <code>post</code> 方法。</p>
<p>从编辑区域获取到 <code>Markdown</code> 之后，用 <code>markdown-it</code> 渲染到右边的预览区域，并且给 <code>markdown-it</code> 添加用来生成锚点链接的 <code>markdown-it-toc</code> 和用来高亮代码的 <code>highlight.js</code> 这两个插件，然后给页面引入 <code>github-markdown</code> 这套用来渲染转化后的 <code>HTML</code> 的 <code>css</code> 以及和 <code>highlight.js</code> 配套的 <code>css</code>，差不多就完工了。</p>
<h2><a id="_Markdown__305"></a>渲染 Markdown 时的注意事项</h2>
<p>但是这里可能要注意一下原本在 <code>Node</code> 里使用的模块在引入浏览器时的用法。</p>
<p>原本作为 <code>Node</code> 模块使用的时候，先</p>
<pre class="hljs"><code class="language-JavaScript"><span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it'</span>);
<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highlight.js'</span>);
<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it-toc'</span>);
</code></pre>
<p>然后</p>
<pre class="hljs"><code class="language-JavaScript"><span class="hljs-keyword">var</span> md = markdownIt({
  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,
  <span class="hljs-attr">xhtmlOut</span>:     <span class="hljs-literal">false</span>,
  <span class="hljs-attr">breaks</span>:       <span class="hljs-literal">false</span>,
  <span class="hljs-attr">langPrefix</span>:   <span class="hljs-string">'language-'</span>,
  <span class="hljs-attr">linkify</span>:      <span class="hljs-literal">false</span>,
  <span class="hljs-attr">typographer</span>:  <span class="hljs-literal">false</span>,
  <span class="hljs-attr">quotes</span>: <span class="hljs-string">'“”‘’'</span>,
  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{
    <span class="hljs-keyword">if</span> (lang && hljs.getLanguage(lang)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;
      } <span class="hljs-keyword">catch</span> (__) {}
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  }
});
md.use(markdownItToc);
</code></pre>
<p>就可以用来渲染 <code>Markdown</code> 了。</p>
<p>但是在浏览器里用的时候总是报错，这个对象找不到，那个对象也找不到，反正我就是没有对象就是了。</p>
<p>后来才发现，作者在写成浏览器用的版本时，暴露出来的变量名的大小写跟我引用的不一样。</p>
<p>我挨个 <code>js</code> 文件打开，发现<code>markdown-it</code> 在浏览器里的变量名是 <code>markdownit</code>，而用来生成锚点链接的 <code>markdown-it-toc</code> 的变量名是 <code>markdownitTOC</code>，于是我把自己的脚本里面的变量名改成跟原变量名一致，然后就有对象可以用了。</p>
<p>这个问题本来不应该是问题的，实在是让人懊恼。</p>
<h2><a id="_349"></a>添加页内平滑滚动效果</h2>
<p>由于文章预览区域加了锚点链接，我希望能做到禁止直接跳转 <code>#</code> 开头的锚点链接，而是平滑滚动到相关位置，这个部分的代码如下：</p>
<pre class="hljs"><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePreview</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>;
  <span class="hljs-keyword">var</span> source = $(<span class="hljs-string">"#editor"</span>).val();
  <span class="hljs-keyword">var</span> html = <span class="hljs-string">"\t"</span> + md.render(<span class="hljs-string">'[toc]\n'</span> + source);
  html = html.replace(<span class="hljs-regexp">/\&lt;a/g</span>,<span class="hljs-string">"&lt;a target='_blank'"</span>);
  $(<span class="hljs-string">"#preview"</span>).html(html);
  <span class="hljs-comment">//add scrollIntoView to anchor link</span>
  <span class="hljs-keyword">var</span> aTags = d.querySelectorAll(<span class="hljs-string">"a[href]"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; aTags.length; i++) {
    <span class="hljs-keyword">if</span> (aTags[i].href.indexOf(<span class="hljs-string">"#"</span>) !== <span class="hljs-number">-1</span>) {
      aTags[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> c = e || event;
        c.preventDefault();
        <span class="hljs-keyword">var</span> href = aTags[i].href;
        <span class="hljs-keyword">var</span> hashPos = href.indexOf(<span class="hljs-string">"#"</span>);
        <span class="hljs-keyword">var</span> id = href.substring(hashPos+<span class="hljs-number">1</span>, href.length);
        d.querySelector(<span class="hljs-string">"a[id='"</span>+<span class="hljs-built_in">String</span>(id)+<span class="hljs-string">"']"</span>).scrollIntoView({<span class="hljs-attr">behavior</span>: <span class="hljs-string">"smooth"</span>});
      }
    }
  }
}
</code></pre>
<h1><a id="_377"></a>大概是这么个效果</h1>
<p>需要访问 <code>API</code> 的时候，可以 <code>cd</code> 进入该 <code>API</code> 的文件夹，然后</p>
<pre class="hljs"><code>node app.js
</code></pre>
<p>再在浏览器里打开 <code>http://127.0.0.1:4000/</code> 这个页面，就能看到文章列表，可以增、删、改文章了。参考以下截图</p>
<p><img src="/img/blog/2020-04-19/001.png" alt="preview"></p>
<h1><a id="_389"></a>心得体会</h1>
<p>今天终于把我心心念念想了一年的东西做出来了，而且只花了一天的时间，真的很开心。</p>
<p>我给它取名叫 <code>April CMS</code>，因为我是在四月里写成的。</p>
<p>做完之后我又研究了下，觉得这个单页面的 <code>CMS</code> 既符合 <code>基于 API 的 Headless CMS</code> 的特征，又符合 <code>Flat File CMS</code> 的特征，也就是 <code>不操作数据库而是操作文本文件的 CMS</code>，感觉好像很高级嘛~</p>
<p>而且预览区和目录区都会随着输入和保存、删除等动作自动更新，写作时无比丝滑顺畅，拿来写文档、写小说啥的好像都不错。</p>
<p>啊，我不知道怎么夸自己才好了。</p>
<p>不说这些肉麻的，总之这次写了个有用的东西，希望以后也能写出更多有用的东西。</p>
</article> <div id="amzn-assoc-ad-51e0e5d0-fdd4-49b3-8945-e3e2f60d21e2"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=51e0e5d0-fdd4-49b3-8945-e3e2f60d21e2"></script> <div class="prev-next"><a href="/blog/script-for-photoshop-bulk-resize-and-watermark-en" class="no-decor-link"><div class="prev"><p>上一篇</p></div></a> <a href="/blog/editor-for-my-cms-of-my-nuxt-blog-en" class="no-decor-link"><div class="next"><p>下一篇</p></div></a></div> <div><h3 style="text-align:center"><span style="border-bottom:2px solid #000">相关文章</span></h3> <div class="blog-gallery"><div class="blog-gallery-unit"><a href="/blog/summary-of-my-life-in-2019" title="我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>2019年的小总结</h4> <p class="blog-date"><span class="fa fa-calendar">
               2020-01-31
            </span></p> <p class="align-left"><span class="blog-gallery-desc">我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                中文
              </span><span class="blog-gallery-tag">
                技术
              </span><span class="blog-gallery-tag">
                生活
              </span><span class="blog-gallery-tag">
                剧评
              </span><span class="blog-gallery-tag">
                Excel
              </span><span class="blog-gallery-tag">
                JavaScript
              </span></span></p></div></a></div><div class="blog-gallery-unit"><a href="/blog/nuxt-blog-static-website" title="重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>如何使用Nuxt建立个人博客</h4> <p class="blog-date"><span class="fa fa-calendar">
               2019-05-05
            </span></p> <p class="align-left"><span class="blog-gallery-desc">重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                中文
              </span><span class="blog-gallery-tag">
                我的项目
              </span><span class="blog-gallery-tag">
                JavaScript
              </span><span class="blog-gallery-tag">
                Node.js
              </span><span class="blog-gallery-tag">
                Nuxt.js
              </span><span class="blog-gallery-tag">
                静态博客
              </span><span class="blog-gallery-tag">
                技术
              </span></span></p></div></a></div></div></div> <div id="comment"></div></section></div></main> <footer><p>Created with Nuxt.js <br>
    	Designed by  
    	<a href="https://github.com/c53hzn" target="_blank" class="no-decor-link"><strong>Jenny HOU</strong> <i class="fa fa-github font-20"></i></a></p> <div class="go-top go-top-hidden"><div class="arrow"></div> <div class="stick"></div></div></footer></div></div></div><script>window.__NUXT__=function(s,a,n,l,e,p,o,c,r,t){return r[0]=l,r[1]=p,r[2]=n,r[3]=o,r[4]="jQuery",{layout:"blog",data:[{relatedBlog:[{layout:s,title:"2019年的小总结",description:"我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。",tags:[l,r[5]=a,"生活","剧评","Excel",n],comments:!0,related_blog:["2020-02-13-tv-drama-die-now","2020-01-31-summary-of-my-life-in-2019","2019-08-17-the-birth-of-the-drama-king"],slug:t,date:"2020-01-31",prev:"why-vlookup-cannot-return-value",next:"memories-about-pandemics"},{layout:s,title:"如何使用Nuxt建立个人博客",description:"重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。",tags:[l,p,n,o,"Nuxt.js","静态博客",a],comments:!0,related_blog:["2020-04-19-editor-for-my-cms-of-my-nuxt-blog","2019-05-18-lighten-nuxt-website","2018-03-28-jekyll-blog-static-website"],slug:c,date:"2019-05-05",prev:"memories-of-the-alhambra-n-feel-good-to-die",next:"lighten-nuxt-website"}],baseURL:"/",ui_str_zh:{to_prev:"上一篇",to_next:"下一篇",related_posts:"相关文章"},ui_str_en:{to_prev:"Previous",to_next:"Next",related_posts:"Related Posts"},blog:{layout:s,title:"给Nuxt使用的基于API的CMS——还有管理后台呢",description:"April CMS，一个兼具Headless CMS和Flat File CMS的特征的操作文本文件的基于API提供内容的CMS，很实用的一个项目哦~",tags:r,comments:!0,related_blog:[t,c],slug:"editor-for-my-cms-of-my-nuxt-blog",date:e,content:'<p><h3> </h3><ul><li><a href="#CMS_1">一个真正的CMS</a></li><li><a href="#_21">后端需要实现的效果</a></li><li><a href="#_30">前端需要实现的效果</a></li><li><a href="#_51">后端的实际写法</a></li><ul><li><a href="#API__53">API 使用的依赖包</a></li><li><a href="#API__HTML__Markdown__100">API 被调用时返回处理后的 HTML 或原 Markdown 内容</a></li><li><a href="#_API__235">给 API 添加管理后台入口</a></li><li><a href="#_262">保存文件和删除文件</a></li></ul><li><a href="#_297">前端的实际写法</a></li><ul><li><a href="#_API__Markdown_299">调用 API 和渲染 Markdown</a></li><li><a href="#_Markdown__305">渲染 Markdown 时的注意事项</a></li><li><a href="#_349">添加页内平滑滚动效果</a></li></ul><li><a href="#_377">大概是这么个效果</a></li><li><a href="#_389">心得体会</a></li></ul></p>\n<h1><a id="CMS_1"></a>一个真正的CMS</h1>\n<p>GitHub 项目地址： <a href="https://github.com/c53hzn/april-cms">https://github.com/c53hzn/april-cms</a></p>\n<p>去年开始学习使用 <code>Nuxt</code> 的时候，看了很多关于 <code>Headless CMS</code> 的介绍，按我的理解，就是 <code>不带前端页面设计的内容管理系统</code> ，研究了一下这类的项目以及相关使用方法，自己也尝试使用了一下，但是没有坚持到底，还是想不依赖这些外部服务来构建自己的网站。不过评论系统和访客统计还是得用外部服务，因为静态网站服务器做不到这些。</p>\n<p>后来我自己写出了可以用作 <code>CMS</code> 的 <code>API</code>，可以参见 <a href="/blog/nuxt-blog-static-website">如何使用Nuxt建立个人博客</a>。</p>\n<p>这个 <code>API</code> 让我可以只需更新 <code>Markdown</code> 文章，再使用 <code>Nuxt</code> 的生成静态页面的功能就可以更新我的网站。通常我是用 <code>Sublime Text</code> 这个编辑器来编写代码的，它可以在左边显示工程文件，切换起来也挺方便的。</p>\n<blockquote>\n<p>可是人类就是喜欢自找麻烦。</p>\n<p>by 我</p>\n</blockquote>\n<p>我想要一个有界面的 <code>CMS</code>，能新建，能修改，能读取，能保存，能删除。但是我只要操作 <code>Markdown</code> 文件，而不要任何数据库。</p>\n<p>我觉得我能做到。</p>\n<p>写了个英文版 <a href="/blog/editor-for-my-cms-of-my-nuxt-blog-en">Write a control panel for my API-based CMS for Nuxt</a>，大家随便看看就好。</p>\n<h1><a id="_21"></a>后端需要实现的效果</h1>\n<p>由于我原本的 <code>API</code> 是用 <code>Node</code> 的 <code>express</code> 写的，所以还是想在此基础上继续精进，那么就需要掌握 <code>Node</code> 服务器的一些用法，比如：</p>\n<ol>\n<li>让 <code>API</code> 读取静态 HTML 页面，使浏览器能显示 <code>CMS</code> 的 UI 界面。</li>\n<li>开启 <code>API</code> 的时候自动打开浏览器访问入口，也就是前一项的 UI 界面。</li>\n<li>让 <code>API</code> 能接受浏览器（客户端）传回来的数据，并保存到本地。</li>\n<li>让 <code>API</code> 接受浏览器传回来的数据，然后删除相关文件。</li>\n</ol>\n<h1><a id="_30"></a>前端需要实现的效果</h1>\n<p>我之前还有一个在 <a href="https://www.codepen.io">CodePen</a> 上的 <a href="https://codepen.io/c53hzn/full/YzzRzxR">Markdown Previewer</a> 的项目，半年来浏览量一只手就能数得清，就这么放着也挺可惜，不如拿来这里用一用。</p>\n<p>CodePen 项目的渲染效果是用 <code>marked</code> 来实现的的，而我的 <code>API</code> 里面是用 <code>markdown-it</code> 来做渲染的，为了统一写法，得把渲染的方式改成 <code>Markdown-it</code>。</p>\n<p>这个项目主体是用 <code>jQuery</code> 写的，我最终决定继续用 <code>jQuery</code> 来写前端的页面交互。</p>\n<p>那么我们就需要解决以下的问题：</p>\n<ol>\n<li>读取 <code>API</code> 传来的文章列表并渲染到文章列表区</li>\n<li>读取 <code>API</code> 传来的文章内容并渲染文章的标题、标签、描述、关联文章、正文到各个输入框，以及最重要的 <code>Markdown</code> 编辑器</li>\n<li>每当 <code>Markdown</code> 编辑器有更新时，预览区也要跟着更新，预览区还应该有代码高亮和一般样式渲染</li>\n<li>点击 <code>Save post</code> 的时候，页面要检查各个输入框是否都有内容，没有则 <code>alert</code> 让填写内容，有的话再检查文章是否已存在，存在则 <code>confirm</code> 要不要更新，不存在则 <code>confirm</code> 要不要创建。</li>\n<li>点击 <code>Delete post</code> 的时候，页面要检查 <code>slug</code> 在文章列表里是否存在，不存在则 <code>alert</code> 说没东西可删，如果存在则要 <code>confirm</code> 是否真的删除。</li>\n<li>键盘按下 <code>ctrl+enter</code> 触发保存，效果等同于点击 <code>Save post</code>。</li>\n<li>当确认要更新或创建的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交内容到服务器，并获取提交结果，反映到浏览器</li>\n<li>当确认要删除的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交要删除的 <code>slug</code> 到服务器，并获取删除结果，反映到浏览器。</li>\n</ol>\n<p>并且这些要在一个页面里完成。</p>\n<h1><a id="_51"></a>后端的实际写法</h1>\n<h2><a id="API__53"></a>API 使用的依赖包</h2>\n<p>先 <code>require</code> 一下各个依赖。</p>\n<pre class=\'hljs\'><code class="language-javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);\n<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);\n<span class="hljs-keyword">var</span> fm = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'front-matter\'</span>);\n<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'highlight.js\'</span>);\n<span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it\'</span>);\n<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it-toc\'</span>);\n<span class="hljs-keyword">var</span> open = <span class="hljs-built_in">require</span>(<span class="hljs-string">"open"</span>);\n<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(__dirname+<span class="hljs-string">"\\\\config.js"</span>);\n<span class="hljs-keyword">var</span> app = express();\n<span class="hljs-keyword">var</span> md = markdownIt({\n  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 在源码中启用 HTML 标签</span>\n  xhtmlOut:     <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 使用 \'/\' 来闭合单标签 （比如 &lt;br /&gt;）。</span>\n  breaks:       <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 转换段落里的 \'\\n\' 到 &lt;br&gt;。</span>\n  langPrefix:   <span class="hljs-string">\'language-\'</span>,  <span class="hljs-comment">// 给围栏代码块的 CSS 语言前缀。对于额外的高亮代码非常有用。</span>\n  linkify:      <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 将类似 URL 的文本自动转换为链接。</span>\n  typographer:  <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">quotes</span>: <span class="hljs-string">\'“”‘’\'</span>,\n  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{\n    <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;\n      } <span class="hljs-keyword">catch</span> (__) {}\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>; <span class="hljs-comment">// 使用额外的默认转义</span>\n  }\n});\nmd.use(markdownItToc);\n</code></pre>\n<p>这里有个 <code>config</code> 是我额外加的配置文件，里面的内容也很简单</p>\n<pre class=\'hljs\'><code class="language-javascript"><span class="hljs-keyword">var</span> config = {\n\t<span class="hljs-attr">isSlugUseDate</span>: <span class="hljs-literal">false</span>,\n\t<span class="hljs-attr">blogPath</span>: __dirname + <span class="hljs-string">\'\\\\blog\'</span>,\n\t<span class="hljs-attr">imgPath</span>: __dirname + <span class="hljs-string">\'\\\\img\\\\blog\'</span>\n};\n<span class="hljs-built_in">module</span>.exports = config;\n</code></pre>\n<p>这个 <code>config</code> 是为了控制 <code>CMS</code> 里面的 <code>Markdown</code> 文件和图片文件的路径，以及 <code>API</code> 返回的 <code>slug</code> 是否使用日期而加的。如果 <code>slug</code> 使用日期，就会是一个长的 <code>slug</code>，比如 <code>2020-04-19-editor-for-my-cms-of-my-nuxt-blog</code>，如果不使用日期，就会是一个短的 <code>slug</code>，比如 <code>editor-for-my-cms-of-my-nuxt-blog</code>，那么相应的，博客文章的 <code>URL</code> 也会有长短之分，就看大家自己喜欢哪一种了。</p>\n<h2><a id="API__HTML__Markdown__100"></a>API 被调用时返回处理后的 HTML 或原 Markdown 内容</h2>\n<p>在 <code>API</code> 的入口文件 <code>app.js</code> 里面做一下配置，这样就可以控制返回的文章正文是 <code>Markdown</code> 还是经过处理的 <code>HTML</code> 内容，同时 <code>API</code> 也会按照 <code>config</code> 里面对 <code>slug</code> 的要求，根据所请求的 <code>slug</code> 返回内容。</p>\n<pre class=\'hljs\'><code class="language-JavaScript"><span class="hljs-keyword">var</span> slugToFileName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">slug,isSlugUseDate</span>) </span>{\n  <span class="hljs-keyword">var</span> result = <span class="hljs-string">""</span>;\n  <span class="hljs-keyword">if</span> (isSlugUseDate) {\n    result = slug+<span class="hljs-string">".md"</span>;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">var</span> files = fs.readdirSync(config.blogPath);\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {\n      <span class="hljs-keyword">let</span> tempSlug = files[i].substring(<span class="hljs-number">11</span>,files[i].length);\n      <span class="hljs-keyword">if</span> (tempSlug == slug+<span class="hljs-string">".md"</span>) {\n        result = files[i];\n        <span class="hljs-keyword">break</span>;\n      }\n    }\n  }\n  <span class="hljs-keyword">return</span> result;\n}\n<span class="hljs-keyword">var</span> fileNameToSlug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename,isSlugUseDate</span>) </span>{\n  <span class="hljs-keyword">if</span> (isSlugUseDate) {\n    <span class="hljs-keyword">return</span> filename.substring(<span class="hljs-number">0</span>,filename.length<span class="hljs-number">-3</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> filename.substring(<span class="hljs-number">11</span>,filename.length<span class="hljs-number">-3</span>);\n  }\n}\n<span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath,slug,isContentRequired,isMD,isDev</span>) </span>{\n  <span class="hljs-keyword">var</span> blog = {};\n  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));\n  blog = content.attributes;\n  blog.slug = slug;\n  <span class="hljs-keyword">var</span> fullFilename = fullPath.replace(config.blogPath+<span class="hljs-string">"\\\\"</span>,<span class="hljs-string">""</span>);\n  blog.date = fullFilename.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);\n  <span class="hljs-keyword">if</span> (isContentRequired &amp;&amp; !isMD) {\n    <span class="hljs-keyword">let</span> html = md.render(<span class="hljs-string">\'@[toc]( )\\n\'</span> + content.body);\n    <span class="hljs-comment">//if isDev then use absolute path for images</span>\n    <span class="hljs-keyword">if</span> (isDev) {\n      html = html.replace(<span class="hljs-regexp">/src=\\"(\\/)?img/g</span>,<span class="hljs-string">"src=\\"http://127.0.0.1:4000/img"</span>);\n    }\n    <span class="hljs-comment">// add class "hljs" for dark theme rendering</span>\n    blog.content = html.replace(<span class="hljs-regexp">/\\&lt;pre/g</span>,<span class="hljs-string">"&lt;pre class=\'hljs\'"</span>);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isContentRequired &amp;&amp; isMD) {\n    blog.content = content.body;\n  }\n  <span class="hljs-keyword">return</span> blog;\n}\n<span class="hljs-comment">//return blog related contents</span>\napp.get(<span class="hljs-string">"/blog"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n  <span class="hljs-comment">// allow cross orign access</span>\n  res.header(<span class="hljs-string">\'Access-Control-Allow-Origin\'</span>, <span class="hljs-string">\'*\'</span>);\n  <span class="hljs-keyword">var</span> blogPath = config.blogPath;\n  <span class="hljs-keyword">var</span> imgPath = config.imgPath;\n  <span class="hljs-keyword">var</span> files = fs.readdirSync(blogPath);\n  <span class="hljs-keyword">var</span> json = {};<span class="hljs-comment">// result to be returned</span>\n  <span class="hljs-keyword">var</span> qSlug = req.query.slug || <span class="hljs-string">""</span>;\n  <span class="hljs-keyword">var</span> qTag = req.query.tag || <span class="hljs-string">""</span>;\n  <span class="hljs-keyword">var</span> qImg = req.query.img || <span class="hljs-string">""</span>;\n  <span class="hljs-keyword">var</span> qIsMD = req.query.ismd == <span class="hljs-string">"true"</span>;\n  <span class="hljs-keyword">var</span> qIsDev = req.query.isdev == <span class="hljs-string">"true"</span>;\n  <span class="hljs-keyword">var</span> isSlugUseDate = (req.query.iseditor == <span class="hljs-string">"true"</span>)?<span class="hljs-literal">true</span>:config.isSlugUseDate;\n  <span class="hljs-keyword">if</span> (qSlug) {<span class="hljs-comment">// with blog slug query</span>\n    json = singleBlog(<span class="hljs-string">`<span class="hljs-subst">${blogPath}</span>\\\\<span class="hljs-subst">${slugToFileName(qSlug,isSlugUseDate)}</span>`</span>,qSlug,<span class="hljs-literal">true</span>,qIsMD,qIsDev);\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; files.length; k++) {<span class="hljs-comment">// add prev and next blog</span>\n      <span class="hljs-keyword">if</span> (qSlug == fileNameToSlug(files[k],isSlugUseDate)) {\n        <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) {\n          json.next = fileNameToSlug(files[k+<span class="hljs-number">1</span>],isSlugUseDate);\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k === files.length<span class="hljs-number">-1</span>) {\n          json.prev = fileNameToSlug(files[k<span class="hljs-number">-1</span>],isSlugUseDate);\n        } <span class="hljs-keyword">else</span> {\n          json.prev = fileNameToSlug(files[k<span class="hljs-number">-1</span>],isSlugUseDate);\n          json.next = fileNameToSlug(files[k+<span class="hljs-number">1</span>],isSlugUseDate);\n        }\n      }\n    }\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qTag) {<span class="hljs-comment">// with tag query</span>\n    <span class="hljs-keyword">if</span> (qTag == <span class="hljs-string">"all_tags"</span>) {<span class="hljs-comment">// returns list of all available tags</span>\n      json.tags = {};\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {\n        <span class="hljs-keyword">let</span> blogPost = singleBlog(blogPath+<span class="hljs-string">"\\\\"</span>+files[i],fileNameToSlug(files[i],isSlugUseDate));\n        <span class="hljs-keyword">let</span> tags = blogPost.tags || [<span class="hljs-string">\'none\'</span>];\n        <span class="hljs-keyword">let</span> entry = {\n          <span class="hljs-attr">title</span>: blogPost.title,\n          <span class="hljs-attr">slug</span>: blogPost.slug\n        };\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {\n          <span class="hljs-keyword">if</span> (json.tags[tags[j]]) {\n            json.tags[tags[j]]++;\n          } <span class="hljs-keyword">else</span> {\n            json.tags[tags[j]] = <span class="hljs-number">1</span>;\n          }\n        }\n      }\n    } <span class="hljs-keyword">else</span> {<span class="hljs-comment">// returns blog list of specific tag</span>\n      json.blogs = [];\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {\n        <span class="hljs-keyword">let</span> blogPost = singleBlog(blogPath+<span class="hljs-string">"\\\\"</span>+files[i],fileNameToSlug(files[i],isSlugUseDate));\n        <span class="hljs-keyword">let</span> tags = blogPost.tags || [<span class="hljs-string">\'none\'</span>];\n        <span class="hljs-keyword">let</span> entry = {\n          <span class="hljs-attr">title</span>: blogPost.title,\n          <span class="hljs-attr">slug</span>: blogPost.slug\n        };\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {\n          <span class="hljs-keyword">if</span> (tags[j] == qTag) {\n            json.blogs.unshift(blogPost);\n          }\n        }\n      }\n    }\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qImg) {<span class="hljs-comment">// with img query</span>\n    <span class="hljs-keyword">if</span> (qImg == <span class="hljs-string">"all_imgs"</span>) {\n      json.imgs = {};\n      <span class="hljs-keyword">var</span> imgFolders = fs.readdirSync(imgPath);\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgFolders.length; i++) {\n        <span class="hljs-keyword">let</span> imgs = fs.readdirSync(imgPath+<span class="hljs-string">"\\\\"</span>+imgFolders[i]);\n        json.imgs[imgFolders[i]] = imgs;\n      }\n    }\n  } <span class="hljs-keyword">else</span> {<span class="hljs-comment">//without requirement, returns list of all blogs</span>\n    json.blogs = [];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {\n      <span class="hljs-keyword">let</span> blogPost = singleBlog(blogPath+<span class="hljs-string">"\\\\"</span>+files[i],fileNameToSlug(files[i],isSlugUseDate));\n      json.blogs.unshift(blogPost);\n    }\n  }\n  res.send(json);\n});\napp.get(<span class="hljs-string">"/config"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n  <span class="hljs-comment">// allow cross orign access</span>\n  res.header(<span class="hljs-string">\'Access-Control-Allow-Origin\'</span>, <span class="hljs-string">\'*\'</span>);\n  res.send(config);\n});\n</code></pre>\n<h2><a id="_API__235"></a>给 API 添加管理后台入口</h2>\n<p>我在 <code>API</code> 所在的文件夹新建了 <code>app.html</code>，以作为 UI 界面的入口，而要让 <code>API</code> 可以访问这个静态页面，就要像下面这样写</p>\n<pre class=\'hljs\'><code class="language-JavaScript"><span class="hljs-comment">//return blog content editor page</span>\napp.use(express.static(__dirname));\napp.get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n    <span class="hljs-comment">// allow cross orign access</span>\n  res.header(<span class="hljs-string">\'Access-Control-Allow-Origin\'</span>, <span class="hljs-string">\'*\'</span>);\n  res.sendFile(__dirname+<span class="hljs-string">"\\\\app.html"</span>);\n});\n<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>\napp.listen(<span class="hljs-number">4000</span>, () =&gt; {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)\n});\n</code></pre>\n<p>那么这个 <code>CMS</code> 的入口链接就是 <code>http://127.0.0.1:4000/</code> 了。</p>\n<p>为了能在开启 <code>API</code> 的时候自动打开浏览器并访问该地址，还需要使用 <code>open</code> 这个 <code>npm</code>，然后加一行打开浏览器的指令</p>\n<pre class=\'hljs\'><code class="language-JavaScript">open(<span class="hljs-string">"http:127.0.0.1:4000/"</span>,{<span class="hljs-attr">app</span>: <span class="hljs-string">"chrome.exe"</span>});\n</code></pre>\n<p>就能直接自动打开浏览器并访问 <code>CMS</code> 的管理界面了。这个界面总共也就一页，所以很好管理。</p>\n<h2><a id="_262"></a>保存文件和删除文件</h2>\n<p>之后就是接受浏览器传回来的数据并保存到本地，或者接收浏览器传回的删除指令，删除相关文件。</p>\n<pre class=\'hljs\'><code class="language-JavaScript"><span class="hljs-comment">//api to submit post</span>\n<span class="hljs-comment">// Parse URL-encoded bodies (as sent by HTML forms)</span>\napp.use(express.urlencoded({ <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));\n<span class="hljs-comment">// Parse JSON bodies (as sent by API clients)</span>\napp.use(express.json());\n<span class="hljs-comment">// Access the parse results as request.body</span>\napp.post(<span class="hljs-string">\'/savepost\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{\n  <span class="hljs-keyword">var</span> obj = req.body;\n  <span class="hljs-keyword">var</span> fileName = config.blogPath+<span class="hljs-string">"\\\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;\n    fs.writeFileSync(fileName, obj.str);\n    <span class="hljs-comment">//Client will get status of failure w/o this</span>\n    <span class="hljs-comment">//even if data is saved to server successfully</span>\n    res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});\n});\n<span class="hljs-comment">// delete post</span>\napp.post(<span class="hljs-string">\'/deletepost\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{\n  <span class="hljs-keyword">var</span> obj = req.body;\n  <span class="hljs-keyword">var</span> fileName = config.blogPath+<span class="hljs-string">"\\\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;\n  <span class="hljs-keyword">try</span> {\n    fs.unlinkSync(fileName);\n    <span class="hljs-comment">//file removed</span>\n  } <span class="hljs-keyword">catch</span>(err) {\n    <span class="hljs-built_in">console</span>.error(err);\n  }\n    <span class="hljs-comment">//Client will get status of failure w/o this</span>\n    <span class="hljs-comment">//even if data is saved to server successfully</span>\n    res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});\n});\n</code></pre>\n<h1><a id="_297"></a>前端的实际写法</h1>\n<h2><a id="_API__Markdown_299"></a>调用 API 和渲染 Markdown</h2>\n<p>具体代码其实没什么好说的，文章列表的 <code>API</code> 是 <code>/blogs</code>，而保存文章的 <code>API</code> 是 <code>/savepost</code>，删除文章的 <code>API</code> 是 <code>/deletepost</code>，获取文章列表可以用 <code>jQuery</code> 的 <code>getJSON</code> 方法，而保存和删除可以用 <code>jQuery</code> 的 <code>post</code> 方法。</p>\n<p>从编辑区域获取到 <code>Markdown</code> 之后，用 <code>markdown-it</code> 渲染到右边的预览区域，并且给 <code>markdown-it</code> 添加用来生成锚点链接的 <code>markdown-it-toc</code> 和用来高亮代码的 <code>highlight.js</code> 这两个插件，然后给页面引入 <code>github-markdown</code> 这套用来渲染转化后的 <code>HTML</code> 的 <code>css</code> 以及和 <code>highlight.js</code> 配套的 <code>css</code>，差不多就完工了。</p>\n<h2><a id="_Markdown__305"></a>渲染 Markdown 时的注意事项</h2>\n<p>但是这里可能要注意一下原本在 <code>Node</code> 里使用的模块在引入浏览器时的用法。</p>\n<p>原本作为 <code>Node</code> 模块使用的时候，先</p>\n<pre class=\'hljs\'><code class="language-JavaScript"><span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it\'</span>);\n<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'highlight.js\'</span>);\n<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it-toc\'</span>);\n</code></pre>\n<p>然后</p>\n<pre class=\'hljs\'><code class="language-JavaScript"><span class="hljs-keyword">var</span> md = markdownIt({\n  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">xhtmlOut</span>:     <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">breaks</span>:       <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">langPrefix</span>:   <span class="hljs-string">\'language-\'</span>,\n  <span class="hljs-attr">linkify</span>:      <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">typographer</span>:  <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">quotes</span>: <span class="hljs-string">\'“”‘’\'</span>,\n  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{\n    <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;\n      } <span class="hljs-keyword">catch</span> (__) {}\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>;\n  }\n});\nmd.use(markdownItToc);\n</code></pre>\n<p>就可以用来渲染 <code>Markdown</code> 了。</p>\n<p>但是在浏览器里用的时候总是报错，这个对象找不到，那个对象也找不到，反正我就是没有对象就是了。</p>\n<p>后来才发现，作者在写成浏览器用的版本时，暴露出来的变量名的大小写跟我引用的不一样。</p>\n<p>我挨个 <code>js</code> 文件打开，发现<code>markdown-it</code> 在浏览器里的变量名是 <code>markdownit</code>，而用来生成锚点链接的 <code>markdown-it-toc</code> 的变量名是 <code>markdownitTOC</code>，于是我把自己的脚本里面的变量名改成跟原变量名一致，然后就有对象可以用了。</p>\n<p>这个问题本来不应该是问题的，实在是让人懊恼。</p>\n<h2><a id="_349"></a>添加页内平滑滚动效果</h2>\n<p>由于文章预览区域加了锚点链接，我希望能做到禁止直接跳转 <code>#</code> 开头的锚点链接，而是平滑滚动到相关位置，这个部分的代码如下：</p>\n<pre class=\'hljs\'><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePreview</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>;\n  <span class="hljs-keyword">var</span> source = $(<span class="hljs-string">"#editor"</span>).val();\n  <span class="hljs-keyword">var</span> html = <span class="hljs-string">"\\t"</span> + md.render(<span class="hljs-string">\'[toc]\\n\'</span> + source);\n  html = html.replace(<span class="hljs-regexp">/\\&lt;a/g</span>,<span class="hljs-string">"&lt;a target=\'_blank\'"</span>);\n  $(<span class="hljs-string">"#preview"</span>).html(html);\n  <span class="hljs-comment">//add scrollIntoView to anchor link</span>\n  <span class="hljs-keyword">var</span> aTags = d.querySelectorAll(<span class="hljs-string">"a[href]"</span>);\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; aTags.length; i++) {\n    <span class="hljs-keyword">if</span> (aTags[i].href.indexOf(<span class="hljs-string">"#"</span>) !== <span class="hljs-number">-1</span>) {\n      aTags[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{\n        <span class="hljs-keyword">var</span> c = e || event;\n        c.preventDefault();\n        <span class="hljs-keyword">var</span> href = aTags[i].href;\n        <span class="hljs-keyword">var</span> hashPos = href.indexOf(<span class="hljs-string">"#"</span>);\n        <span class="hljs-keyword">var</span> id = href.substring(hashPos+<span class="hljs-number">1</span>, href.length);\n        d.querySelector(<span class="hljs-string">"a[id=\'"</span>+<span class="hljs-built_in">String</span>(id)+<span class="hljs-string">"\']"</span>).scrollIntoView({<span class="hljs-attr">behavior</span>: <span class="hljs-string">"smooth"</span>});\n      }\n    }\n  }\n}\n</code></pre>\n<h1><a id="_377"></a>大概是这么个效果</h1>\n<p>需要访问 <code>API</code> 的时候，可以 <code>cd</code> 进入该 <code>API</code> 的文件夹，然后</p>\n<pre class=\'hljs\'><code>node app.js\n</code></pre>\n<p>再在浏览器里打开 <code>http://127.0.0.1:4000/</code> 这个页面，就能看到文章列表，可以增、删、改文章了。参考以下截图</p>\n<p><img src="/img/blog/2020-04-19/001.png" alt="preview"></p>\n<h1><a id="_389"></a>心得体会</h1>\n<p>今天终于把我心心念念想了一年的东西做出来了，而且只花了一天的时间，真的很开心。</p>\n<p>我给它取名叫 <code>April CMS</code>，因为我是在四月里写成的。</p>\n<p>做完之后我又研究了下，觉得这个单页面的 <code>CMS</code> 既符合 <code>基于 API 的 Headless CMS</code> 的特征，又符合 <code>Flat File CMS</code> 的特征，也就是 <code>不操作数据库而是操作文本文件的 CMS</code>，感觉好像很高级嘛~</p>\n<p>而且预览区和目录区都会随着输入和保存、删除等动作自动更新，写作时无比丝滑顺畅，拿来写文档、写小说啥的好像都不错。</p>\n<p>啊，我不知道怎么夸自己才好了。</p>\n<p>不说这些肉麻的，总之这次写了个有用的东西，希望以后也能写出更多有用的东西。</p>\n',prev:"script-for-photoshop-bulk-resize-and-watermark-en",next:"editor-for-my-cms-of-my-nuxt-blog-en"},tags:r,date:e}],fetch:[],error:null,state:{lang:{val:"Chi",ui:"English",title:"Change navigation to English"}},serverRendered:!0,routePath:"/blog/editor-for-my-cms-of-my-nuxt-blog"}}("post","技术","JavaScript","中文","2020-04-19","我的项目","Node.js","nuxt-blog-static-website",Array(6),"summary-of-my-life-in-2019")</script><script src="/_nuxt/0109b093b32bbe681dcb.js" defer></script><script src="/_nuxt/7c82ebcda90129e59b83.js" defer></script><script src="/_nuxt/8c2350c4dfed45e215a8.js" defer></script><script src="/_nuxt/c4b816bfcec5991a02bc.js" defer></script>
  </body>
</html>
