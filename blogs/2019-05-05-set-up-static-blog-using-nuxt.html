<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">如何使用Nuxt建立个人博客 | Jenny的小站</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面"><meta data-n-head="true" data-hid="keyword" name="keyword" content="涨知识, Nuxt, 静态博客"><link data-n-head="true" rel="icon" type="image/x-icon" href="/img/favicon.ico"><link data-n-head="true" rel="stylesheet" href="/css/font-gugi.css"><link data-n-head="true" rel="stylesheet" href="/css/font-poppins.css"><link data-n-head="true" rel="stylesheet" href="/css/style.css?2020-03-21"><link data-n-head="true" rel="stylesheet" href="/font-awesome/css/font-awesome.min.css"><link data-n-head="true" rel="stylesheet" href="/css/github-markdown.min.css"><link data-n-head="true" rel="stylesheet" href="/css/highlight.js.css"><link data-n-head="true" rel="stylesheet" href="https://hzn-website.000webhostapp.com/disqus/dist/iDisqus.min.css"><script data-n-head="true" src="/js/statcounter.js"></script><base href="/"><link rel="preload" href="/_nuxt/859ccb1ab7a988ba93fe.js" as="script"><link rel="preload" href="/_nuxt/e538c0d34daa29c0b6a1.js" as="script"><link rel="preload" href="/_nuxt/c50eecc5d001f3cf9b3f.js" as="script"><link rel="preload" href="/_nuxt/dce006513b8e822894f0.js" as="script"><style data-vue-ssr-id="17cfdfa9:0 498b36b5:0 1bd5369a:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#3b8070;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}.markdown-body{margin-bottom:50px}.markdown-body img{max-height:100px}a[id]{position:relative;top:-40px;display:block}a#comment-link{top:0}.blog-desc{margin:10px;padding:10px;color:#666;background-color:rgba(0,0,0,.025)}.youtube-img{position:relative;display:inline-block}.youtube-img:before{width:40%;height:40%;border-radius:25%;background:rgba(0,0,0,.7);transition:background .2s}.youtube-img:after,.youtube-img:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.youtube-img:after{width:0;height:0;border-top:10px solid transparent;border-left:20px solid #fff;border-bottom:10px solid transparent}.youtube-img:hover:before{background:red}#disqus_thread{margin-top:20px}.prev-next{margin:20px auto;display:block}.prev-next:after{display:table;content:" ";clear:both}.prev-next a{display:inline}.next,.prev{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin:20px auto;width:100%;color:grey;border:1px solid grey;cursor:pointer}.prev{width:48%;text-align:left;float:left}.next{width:48%;text-align:right;float:right}.next:hover,.prev:hover{color:#000;border-color:#000}.prev p{padding-left:16px}.next p,.prev p{margin:0;padding-top:16px;padding-bottom:16px}.next p{padding-right:16px}#comment{margin-top:40px}.blog-gallery{margin:20px auto;display:flex;justify-content:center;flex-wrap:wrap;overflow:hidden}.blog-gallery-unit{margin:40px 10px 0;width:46%;border:1px solid silver;border-radius:5px}.blog-gallery-unit:first-child,.blog-gallery-unit:nth-child(2){margin-top:20px}.blog-gallery-unit:hover{border-color:#000}.blog-gallery-inner{padding:21px 10px 10px;height:100%}.blog-gallery-inner h4{margin-top:0;max-height:42px;overflow:hidden}.blog-gallery-desc{line-height:21px;max-height:64px;display:block;overflow:hidden}.blog-gallery-tag{margin:1px;padding:0 8px;color:#fff;font-size:12px;font-family:Microsoft Yahei;line-height:20px;border-radius:999px;background:grey;display:inline-block}@media (max-width:425px){.blog-gallery-unit{width:100%}}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="container"><nav><div class="nav-wrap"><header><a href="/" class="no-decor-link"><p class="nav-home">Jenny's blog</p></a></header> <div class="nav-btn"><div class="bar"></div> <div class="bar"></div> <div class="bar"></div> <div class="bar"></div></div> <div class="nav-mask"></div> <div class="body-mask"></div> <ul class="nav-ul"><a href="/" target="_self" class="nav-link"><li>首页<!----><!----></li></a><a href="/resume" target="_self" class="nav-link"><li>简历<!----><!----></li></a><a href="/blogs" target="_self" class="nav-link nuxt-link-active"><li>博客<!----><!----></li></a><a href="https://wj.qq.com/s2/3731207/f0cd/" target="_blank" class="nav-link"><li>联系我<span> </span><i class="fa fa-external-link"></i></li></a></ul></div></nav> <main><div><section class="main-content"><h1 class="align-center">如何使用Nuxt建立个人博客</h1> <p class="blog-date align-center"><span class="fa fa-calendar"> 2019-05-05</span></p> <p class="blog-tags align-center"><a href="/blogs/tag/涨知识"><span class="blog-tag">涨知识</span></a><a href="/blogs/tag/Nuxt"><span class="blog-tag">Nuxt</span></a><a href="/blogs/tag/静态博客"><span class="blog-tag">静态博客</span></a></p> <div class="blog-desc">Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面</div> <article class="markdown-body"><p><h3> </h3><ul><li><a href="#_1">前言</a></li><li><a href="#_Nuxt_9">关于 Nuxt</a></li><li><a href="#_19">我的个人网站需要实现什么功能？</a></li><li><a href="#_31">我需要学会哪些技能？有什么好的教学资源？</a></li><ul><li><a href="#Youtube__35">Youtube 教学视频</a></li><li><a href="#_57">网络文章教程（日、英）</a></li></ul><li><a href="#_70">我的网站构建过程</a></li><ul><li><a href="#_72">项目结构</a></li><li><a href="#_CMS__API_112">作为 CMS 作用的 API</a></li><ul><li><a href="#Markdown_114">Markdown文件的写法</a></li><li><a href="#_136">根据参数读取并返回数据</a></li></ul><li><a href="#_API__248">从 API 读取数据并渲染到页面</a></li><li><a href="#_323">生成静态页面</a></li><li><a href="#_360">小插曲</a></li><ul><li><a href="#_362">路由和内部链接</a></li><li><a href="#_370">根目录</a></li></ul></ul><li><a href="#_382">心得体会</a></li></ul></p>
<h1><a id="_1"></a>前言</h1>
<p>更新日期：2020-03-18</p>
<p>之前写的版本有点乱，想到哪写到哪，如果是路人从 Google 点进来，也许看不明白我写了些啥，所以我把文章重构了一下。</p>
<p>我的网站从2018年3月17日至2019年5月5日期间用的是 Jekyll，主题叫 Hydejack，由 Github 自带的 Ruby 后台驱动。从2019年5月6日开始转为使用 Nuxt 生成的纯静态页面，主题是我自己设计的，没名字，本篇文章会讲述使用 Nuxt 设计博客网站的过程和要点。</p>
<h1><a id="_Nuxt_9"></a>关于 Nuxt</h1>
<p>官网在<a href="https://zh.nuxtjs.org/guide/">这里</a>。</p>
<blockquote>
<p>Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染( SSR ) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等优势。</p>
</blockquote>
<p>也就是说，如果你想做一个有后台的动态网站，可以用 Nuxt 直接部署到 Node 服务器上。</p>
<p>如果你只是想做一个静态网站，则可以用 Nuxt 生成静态页面，然后把静态页面上传到 Github 或者任何支持静态页面托管服务的网站，本站就是这样做的。</p>
<h1><a id="_19"></a>我的个人网站需要实现什么功能？</h1>
<p>我参考了 <code>Jekyll</code>、<code>Hexo</code>、<code>Hugo</code> 等静态网站生成工具，它们能够做到的，我希望我的网站也能做到。</p>
<p>作为个人网站来说，能够写日志是最基本的，那么它就需要有以下的功能：</p>
<ul>
<li>文章列表页</li>
<li>文章详情页（要能显示文章详情，有上一篇、下一篇按钮，并推荐相关文章）</li>
<li>标签列表页</li>
<li>标签下文章列表页</li>
</ul>
<p>然后再来几个独立页面，最好能有简历页、联络页，首页最好能推送最新文章，推送内容需包括文章标题、日期、标签、内容简介。</p>
<h1><a id="_31"></a>我需要学会哪些技能？有什么好的教学资源？</h1>
<p><code>Node</code>、<code>Vue</code> 和 <code>NPM</code> 是最基本的，而设计网站 UI 就比较随缘了，除了渲染 Markdown 用的 CSS 是从外部导入的之外，其他的主要设计都是我自己完成的。本篇文章不会讲任何 Vue 模板的基础知识，包括渲染数据和页面交互等。而 Nuxt 方面的教学，我主要参考了以下的一些资源。</p>
<h2><a id="Youtube__35"></a>Youtube 教学视频</h2>
<p>我在 Youtube 上搜了很多，最后完整地看了的，并且觉得有用的大概是以下这些</p>
<ol>
<li>
<p>使用 Nuxt 生成静态网站<br>
<a href="https://www.youtube.com/watch?v=pI2qHPI0ZpU" title="Nuxt.js - Static Site Generator"><img src="/img/blogs/2019-05-05/youtube05.jpg" alt="youtube-img"></a><br>
这一个视频的主要内容是不使用外部资源，所有页面都用 <code>.vue</code> 的文件书写，最后生成静态网站。这样比较适合那种做好之后不会做什么大变动的网站，比如企业官网之类的。但博客文章不可能都用 <code>.vue</code> 文件来写，网站也不可能长久不更新，所以很显然不能直接用这个办法来做。</p>
</li>
<li>
<p>使用 Nuxt (框架)和 <a href="https://www.storyblok.com/">storyblok</a> (基于 api 提供内容的 CMS )建立个人博客<br>
<a href="https://www.youtube.com/watch?v=Dc_5BpIB4X4" title="The Front-End | Nuxt.js &amp; Storyblok - Building a Complete Blog"><img src="/img/blogs/2019-05-05/youtube01.jpg" alt="youtube-img"></a>
<a href="https://www.youtube.com/watch?v=UIh4P5rNjac" title="Adding Storyblok CMS | Nuxt.js &amp; Storyblok - Building a Complete Blog"><img src="/img/blogs/2019-05-05/youtube02.jpg" alt="youtube-img"></a>
<a href="https://www.youtube.com/watch?v=Yq6Ddu_QAiY" title="Storyblok Live Preview! | Nuxt.js &amp; Storyblok - Building a Complete Blog"><img src="/img/blogs/2019-05-05/youtube03.jpg" alt="youtube-img"></a>
<a href="https://www.youtube.com/watch?v=JHCKab2oS4s" title="Final Touches &amp; Deploying the Blog | Nuxt.js &amp; Storyblok - Building a Complete Blog"><img src="/img/blogs/2019-05-05/youtube04.jpg" alt="youtube-img"></a><br>
这个系列的视频主要内容是使用 Nuxt 建立博客首页（文章列表页）、附属页面，建立页面导航路由，然后在博客详情页用 <code>Axios</code> 加载 api 传来的文章内容，最后生成静态网站。<br>
这里有一点很重要的是，up 主的博客内容是托管在 <a href="https://www.storyblok.com/">storyblok</a> 这个 CMS 上，不在电脑本地，也不是用 Markdown 来书写。除了 <a href="https://www.storyblok.com/">storyblok</a> 之外还有 <a href="https://www.contentful.com/">contentful</a> 等提供内容管理的网站，也能达到相同的效果。<br>
但是对于像我这样从 Jekyll 转过来的人来说，还是想找找能继续用 Markdown 写文章的办法。这里的“使用 CMS 的 api 来提供博客内容”的思路值得我参考。如果不使用外部商业 CMS 服务，我自己能不能在本地搭建一个类似的服务呢？只要有提供内容的 api，我就可以跟 up 主一样成功生成静态网站了。</p>
</li>
<li>
<p>手把手教你在 Nuxt 项目中使用 serverMiddleware<br>
<a href="https://www.youtube.com/watch?v=j-3RwvWZoaU" title="Why You Should Learn Server Middleware with Nuxt.js! A step-by-step tutorial!"><img src="/img/blogs/2019-05-05/youtube06.jpg" alt="youtube-img"></a><br>
这个视频教了一下作为服务端渲染的 Nuxt 里面配置 <code>serverMiddleware</code> 的 api 的简单过程，以及 api 的服务端代码怎么写。如果我是做动态网站，那么使用这个 api 来解析我的 Markdown 文件来提供文章内容，网站就可以直接上线了。<br>
由于我是要做纯静态网站，所以用不到 serverMiddleware，但是它这里配置后台 api 的代码对我来说很有用，我们可以不用 serverMiddleware，而是单独开一个 api 的服务出来，解析 Markdown 文件，返回 json，这样就等于有了一个自己的 CMS 啦！</p>
</li>
</ol>
<h2><a id="_57"></a>网络文章教程（日、英）</h2>
<p>中文世界里的文字教程也是有的，但是英文和日文的更能学到东西。</p>
<ol>
<li>
<p><strong>使用 Nuxt + Markdown 创建个人博客（英文）</strong><a href="https://marinaaisa.com/blog/blog-using-vue-nuxt-markdown">链接</a><br>
作者成功实现了在 Nuxt 单一服务下解析 Markdown 文件的效果，但是她的做法竟然需要事先准备好一个 js 文件作为文章列表，每新增一个 Markdown 文件，就在 js 文件里面<strong>手动</strong>添加一篇文章的标题和链接，这样才能做到更新。而我这边希望网站可以<strong>自动</strong>识别新增的文章，所以她的这个办法可能不适合我。<br>
作者也很大方地把网站源码发出来了，她的 repo 在 <a href="https://github.com/marinaaisa/nuxt-markdown-blog-starter">这里</a>。<br>
作者的页面设计和排版很符合国外网站的审美，简洁、大气、好看，不过博客文章没有标签系统，算是一个小的缺憾吧。</p>
</li>
<li>
<p><strong>使用 Nuxt 重构网站（日文）</strong><a href="https://blog.nakamu.life/posts/replace-tech-blog">链接</a><br>
找教程居然找到日文的，我也是很佩服我自己。作者的文字不难懂，搭建流程和技术要点解释得也很清楚。作者是用 <a href="https://www.contentful.com/">contentful</a> 来提供内容的，这样就和前面的 Youtube 教程重复了。但是他的 UI 设计得很好，完全不像一般日本人的风格，非常值得参考。<br>
作者自己的技术博客用的是 Nuxt 搭建的，链接在 <a href="https://marinaaisa.com/blog/blog-using-vue-nuxt-markdown">这里</a> 此外还有一个用 Gatsby(React) 设计的生活博客，链接在 <a href="https://enjoyhk.nakamu.life/">这里</a> 可惜我之前学的那点 React 都忘光了，不然也可以参考这个。</p>
</li>
</ol>
<h1><a id="_70"></a>我的网站构建过程</h1>
<h2><a id="_72"></a>项目结构</h2>
<pre><code>myblog
├─ api    //☆手动建立这个文件夹☆
│   ├─ blogs    //需要api解析的Markdown文件夹
│   │   ├─ 2019-05-05-set-up-static-blog-using-nuxt.md
│   │   ├─ 2017-05-28-hao123-issue.md
│   │   └─ ...
│   └─ index.js //api的入口，默认路径http://127.0.0.1:4000
├─ components
│   ├─ Footer.vue
│   └─ Navigation.vue
├─ dist        //☆最后生成的静态文件在这里，上传到 GitHub 就行啦☆
├─ layouts
│   ├─ default.vue //Navigation + Nuxt(主要内容) + Footer
│   └─ error.vue //动态部署时会显示这个，但静态网页找不到时会去服务器（GitHub）的404页
├─ pages
│   ├─ blogs
│   │   ├─ tag
│   │   │   ├─ _tag.vue  //动态渲染标签下的文章列表
│   │   │   │            eg =&gt; /blogs/tag/aaa.html
│   │   │   └─ index.vue //文章标签列表页 =&gt; /blogs/tag.html
│   │   ├─ _slug.vue //动态渲染文章详情页
│   │   │                 eg =&gt; /blogs/2019-05-05-set-up-static-blog-using-nuxt.html
│   │   └─ index.vue //文章列表页 =&gt; /blogs.html
│   ├─ resume.vue
│   └─ index.vue     //网站入口 =&gt; /index.html
├─ static
│   ├─ img  //引用路径 /img/home/bg.jpg
│   │   └─ home
│   │       └─ bg.jpg
│   ├─ js  //引用路径 /js/jquery.js
│   │   └─ jquery.js
│   ├─ favicon.ico  //网站图标 =&gt; /favicon.ico
│   └─ styles.css   //公用css =&gt; /styles.css
├─ nuxt.config.js  //nuxt网站整体设置
└─ ...
</code></pre>
<h2><a id="_CMS__API_112"></a>作为 CMS 作用的 API</h2>
<h3><a id="Markdown_114"></a>Markdown文件的写法</h3>
<p>基本上跟原先 Jekyll 里用的 Markdown 文件写法一样，但是为了能添加“相关文章”功能，我在 Markdown 里新增了一个属性 <code>related_blog</code>，里面填写关联的文章的不包含扩展名的文件名即可。</p>
<pre><code>---
layout: post
title: 如何使用Nuxt建立个人博客
description: Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面
tags: [涨知识,Nuxt,静态博客]
comments: true
related_blog: [2018-03-28-set-up-static-blog]
---
# 标题一

asdf

# 标题二

asdf
</code></pre>
<h3><a id="_136"></a>根据参数读取并返回数据</h3>
<p>在这个 api 里面，我直接把读取的 Markdown 内容转化成了 HTML，这样可以减轻最后生成的网站文件大小，原因可见<a href="/blogs/2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs">这篇文章</a>。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">var</span> fm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'front-matter'</span>);
<span class="hljs-keyword">var</span> app = express();
<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highlight.js'</span>);
<span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it'</span>);
<span class="hljs-keyword">var</span> md = markdownIt({
  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 在源码中启用 HTML 标签</span>
  xhtmlOut:     <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 使用 '/' 来闭合单标签 （比如 &lt;br /&gt;）。</span>
  breaks:       <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 转换段落里的 '\n' 到 &lt;br&gt;。</span>
  langPrefix:   <span class="hljs-string">'language-'</span>,  <span class="hljs-comment">// 给围栏代码块的 CSS 语言前缀。对于额外的高亮代码非常有用。</span>
  linkify:      <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 将类似 URL 的文本自动转换为链接。</span>
  typographer:  <span class="hljs-literal">false</span>,
  <span class="hljs-attr">quotes</span>: <span class="hljs-string">'“”‘’'</span>,
  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{
    <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;
      } <span class="hljs-keyword">catch</span> (__) {}
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>; <span class="hljs-comment">// 使用额外的默认转义</span>
  }
});

<span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath, slug, isContentRequired</span>) </span>{
  <span class="hljs-keyword">var</span> blog = {};
  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));
  blog = content.attributes;
  blog.slug = slug;
  <span class="hljs-keyword">if</span> (isContentRequired) {
    blog.content = md.render(content.body);
  }
  <span class="hljs-keyword">return</span> blog;
}

app.get(<span class="hljs-string">"/blogs"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// allow cross orign access, because api and Nuxt are served separately</span>
  res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
  <span class="hljs-keyword">var</span> path = __dirname + <span class="hljs-string">'\\blogs'</span>;
  <span class="hljs-keyword">var</span> files = fs.readdirSync(path);
  <span class="hljs-keyword">var</span> json = {};<span class="hljs-comment">// result to be returned</span>
  <span class="hljs-keyword">var</span> qSlug = req.query.slug || <span class="hljs-string">""</span>;
  <span class="hljs-keyword">var</span> qTag = req.query.tag || <span class="hljs-string">""</span>;
  <span class="hljs-keyword">if</span> (qSlug) {<span class="hljs-comment">// with blog slug query</span>
    json = singleBlog(path+<span class="hljs-string">"\\"</span>+qSlug+<span class="hljs-string">".md"</span>, qSlug, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; files.length; k++) {<span class="hljs-comment">// add prev and next blog</span>
      <span class="hljs-keyword">if</span> (qSlug == files[k].replace(<span class="hljs-string">".md"</span>, <span class="hljs-string">""</span>)) {
        <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) {
          json.next = files[k+<span class="hljs-number">1</span>].replace(<span class="hljs-string">".md"</span>,<span class="hljs-string">""</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k === files.length<span class="hljs-number">-1</span>) {
          json.prev = files[k<span class="hljs-number">-1</span>].replace(<span class="hljs-string">".md"</span>,<span class="hljs-string">""</span>);
        } <span class="hljs-keyword">else</span> {
          json.prev = files[k<span class="hljs-number">-1</span>].replace(<span class="hljs-string">".md"</span>,<span class="hljs-string">""</span>);
          json.next = files[k+<span class="hljs-number">1</span>].replace(<span class="hljs-string">".md"</span>,<span class="hljs-string">""</span>);
        }
      }
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qTag) {<span class="hljs-comment">// with tag query</span>
    <span class="hljs-keyword">if</span> (qTag == <span class="hljs-string">"all_tags"</span>) {<span class="hljs-comment">// returns list of all available tags</span>
      json.tags = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
        <span class="hljs-keyword">let</span> blogPost = singleBlog(path+<span class="hljs-string">"\\"</span>+files[i], files[i].replace(<span class="hljs-string">".md"</span>, <span class="hljs-string">""</span>));
        <span class="hljs-keyword">let</span> tags = blogPost.tags || [<span class="hljs-string">'none'</span>];
        <span class="hljs-keyword">let</span> entry = {
          <span class="hljs-attr">title</span>: blogPost.title,
          <span class="hljs-attr">slug</span>: blogPost.slug
        };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {
          <span class="hljs-keyword">if</span> (json.tags[tags[j]]) {
            json.tags[tags[j]].unshift(entry);
          } <span class="hljs-keyword">else</span> {
            json.tags[tags[j]] = [];
            json.tags[tags[j]].unshift(entry);
          }
        }
      }
    } <span class="hljs-keyword">else</span> {<span class="hljs-comment">// returns blog list of specific tag</span>
      json.blogs = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
        <span class="hljs-keyword">let</span> blogPost = singleBlog(path+<span class="hljs-string">"\\"</span>+files[i], files[i].replace(<span class="hljs-string">".md"</span>, <span class="hljs-string">""</span>));
        <span class="hljs-keyword">let</span> tags = blogPost.tags || [<span class="hljs-string">'none'</span>];
        <span class="hljs-keyword">let</span> entry = {
          <span class="hljs-attr">title</span>: blogPost.title,
          <span class="hljs-attr">slug</span>: blogPost.slug
        };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {
          <span class="hljs-keyword">if</span> (tags[j] == qTag) {
            json.blogs.unshift(blogPost);
          }
        }
      }
    }
  } <span class="hljs-keyword">else</span> {<span class="hljs-comment">//without requirement, returns list of all blogs</span>
    json.blogs = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
      <span class="hljs-keyword">let</span> blogPost = singleBlog(path+<span class="hljs-string">"\\"</span>+files[i], files[i].replace(<span class="hljs-string">".md"</span>, <span class="hljs-string">""</span>));
      json.blogs.unshift(blogPost);
    }
  }
  res.send(json);
});
<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>
app.listen(<span class="hljs-number">4000</span>, () =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)
});
</code></pre>
<h2><a id="_API__248"></a>从 API 读取数据并渲染到页面</h2>
<p>在 <code>/blogs/index.vue</code> 页面用 <code>asyncData</code> 方法来加载数据</p>
<p>记得要先 <code>import axios from 'axios'</code>，然后</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">layout</span>: <span class="hljs-string">"default"</span>,
  asyncData(context) {
    <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'http://127.0.0.1:4000/blogs'</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> { 
        <span class="hljs-attr">blogs</span>: res.data.blogs,
        <span class="hljs-attr">baseURL</span>: context.app.router.options.base
      };
    })
  }
</code></pre>
<p>在 <code>/blogs/_slug.vue</code> 页面同样用 <code>asyncData</code> 方法来加载数据</p>
<pre><code class="language-javascript">asyncData(context) {
  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'http://127.0.0.1:4000/blogs?slug='</span>+context.params.slug).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> blog = res.data;
    <span class="hljs-keyword">let</span> space = [];
    <span class="hljs-keyword">let</span> related = blog.related_blog;
    <span class="hljs-keyword">if</span> (!related) {
      related = [];
    }
    <span class="hljs-keyword">var</span> requests = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; related.length; i++) {
      <span class="hljs-keyword">let</span> blogJson = axios.get(<span class="hljs-string">'http://127.0.0.1:4000/blogs?slug='</span>+related[i])
      .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {<span class="hljs-comment">// res.data is json</span>
        <span class="hljs-keyword">let</span> temp = res.data;
        <span class="hljs-keyword">if</span> (temp) {
          <span class="hljs-keyword">delete</span> res.data.content;
          res.data.date = res.data.slug.substring(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
          <span class="hljs-keyword">return</span> res.data;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> {};
        }
       });
       requests.push(blogJson);
    };
    <span class="hljs-keyword">if</span> (requests.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(requests).then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> related_results = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>; m &lt; values.length; m++) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">JSON</span>.stringify(values[m]) != <span class="hljs-string">"{}"</span>) {
            related_results.push(values[m])
          }
        }
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">blog</span>: blog,
          <span class="hljs-attr">tags</span>: blog.tags || [<span class="hljs-string">'none'</span>],
          <span class="hljs-attr">date</span>: context.params.slug.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>),
          <span class="hljs-attr">relatedBlog</span>: related_results,
        }
      })
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">blog</span>: blog,
        <span class="hljs-attr">tags</span>: blog.tags || [<span class="hljs-string">'none'</span>],
        <span class="hljs-attr">date</span>: context.params.slug.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>),
        <span class="hljs-attr">relatedBlog</span>: [],
        <span class="hljs-attr">baseURL</span>: context.app.router.options.base,
      };
    } 
  })
}
</code></pre>
<p>标签页等等就不赘述了。</p>
<h2><a id="_323"></a>生成静态页面</h2>
<p>生成静态页面的命令是 <code>npm run generate</code>，如果不做特殊设置的话，系统只会为 <code>pages</code> 文件夹及子文件夹里所有不是以下划线开头的 <code>.vue</code> 文件生成页面，也就是说，那些用 <code>_slug.vue</code> 和 <code>_tag.vue</code> 来动态获取的页面不会生成相应的静态页面，而如果想生成的话，就需要在 <code>nuxt.config.js</code> 这个文件里面设置要动态生成的 <code>routes</code>。</p>
<p>并且 Nuxt 默认是为每个页面生成各自的文件夹，在文件夹里生成 <code>index.html</code> 文件来访问，也就是说，本篇文章可以用 <code>/blogs/2019-05-05-set-up-static-blog-using-nuxt/</code> 来访问，也可以用 <code>2019-05-05-set-up-static-blog-using-nuxt/index.html</code> 来访问。但是想象一下这个文件夹的数量，还是取消吧！</p>
<pre><code class="language-javascript">generate: {
  <span class="hljs-attr">subFolders</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//if true, each page or post will have their own folder</span>
  routes: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> blogs = axios.get(<span class="hljs-string">'http://127.0.0.1:4000'</span>)
    .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {<span class="hljs-comment">// res.data is array</span>
      <span class="hljs-keyword">return</span> res.data.blogs.map(<span class="hljs-function">(<span class="hljs-params">blog</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">route</span>: <span class="hljs-string">'/blogs/'</span> + blog.slug,
          <span class="hljs-attr">payload</span>: blog
        }
      })
    })
    <span class="hljs-keyword">let</span> tags = axios.get(<span class="hljs-string">'http://127.0.0.1:4000?tag=all_tags'</span>)
    .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {<span class="hljs-comment">// res.data is object</span>
      <span class="hljs-keyword">let</span> tags = <span class="hljs-built_in">Object</span>.keys(res.data.tags);
      <span class="hljs-keyword">return</span> tags.map(<span class="hljs-function">(<span class="hljs-params">tag</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">route</span>: <span class="hljs-string">'/blogs/tag/'</span> + tag,
          <span class="hljs-attr">payload</span>: tag
        };
      });
    })
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([blogs, tags]).then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> [...values[<span class="hljs-number">0</span>], ...values[<span class="hljs-number">1</span>]]
    })
  },
  ...
}
</code></pre>
<h2><a id="_360"></a>小插曲</h2>
<h3><a id="_362"></a>路由和内部链接</h3>
<p>本来页面导航栏和各种链接应该要使用 <code>&lt;nuxt-link/&gt;</code> 标签的，这样就可以用Nuxt的路由机制，加快访问速度。</p>
<p>但是它有一个问题是，在最终生成的静态网站上使用路由访问的时候，页面仍然会去请求 <code>127.0.0.1:4000</code> 上的内容，可是这时候 api 已经关闭了，请求失败之后页面就会来个“Network error”，可是如果使用URL去访问，又是可以加载出内容的。</p>
<p>所以我不得不忍痛割爱，把所有 <code>&lt;nuxt-link/&gt;</code>的链接都换成了普通的 <code>&lt;a&gt;&lt;/a&gt;</code> 标签的链接，这样静态网站就可以正常使用了。</p>
<h3><a id="_370"></a>根目录</h3>
<p>如果你的网站不在服务器的根目录里，而是像 <code>xxx.github.io/myproject</code> 这样的路径的话，就需要在 <code>nuxt.config.js</code> 里面设置</p>
<pre><code class="language-javascript">router: {
  <span class="hljs-attr">base</span>: <span class="hljs-regexp">/myproject/</span>
}
</code></pre>
<p>然后不管是动态还是静态的网站应该都是正确的链接了。</p>
<h1><a id="_382"></a>心得体会</h1>
<p>前前后后花了两个多星期，我的博客终于有了新面貌，然而在这个过程中最惊喜的还是 Youtube，想找什么样的教学视频都有。</p>
<p>而且它自动生成的字幕非常有用，各个国家千奇百怪的口音竟然都能识别出来，即使不是100%匹配，也能让我这个非英语母语的人跟上视频博主的思路。</p>
<p>在这里给 Youtube 点个赞！</p>
</article> <div class="prev-next"><a href="/blogs/2018-12-21-Korean-drama-memories-of-the-alhambra-n-feel-good-to-die" class="no-decor-link"><div class="prev"><p>上一篇</p></div></a> <a href="/blogs/2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs" class="no-decor-link"><div class="next"><p>下一篇</p></div></a></div> <div><h3 style="text-align:center"><span style="border-bottom:2px solid #000">相关文章</span></h3> <div class="blog-gallery"><div class="blog-gallery-unit"><a href="/blogs/2018-03-28-set-up-static-blog" title="我的个人博客 = Github代码托管 + Jekyll模板 + Godaddy域名 + Cloudflare安全认证 + disqus评论系统 + 反向代理访问disqus(墙内) + zoho自主域名邮箱" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>如何搭建静态个人博客</h4> <p class="blog-date"><span class="fa fa-calendar">
               2018-03-28
            </span></p> <p class="align-left"><span class="blog-gallery-desc">我的个人博客 = Github代码托管 + Jekyll模板 + Godaddy域名 + Cloudflare安全认证 + disqus评论系统 + 反向代理访问disqus(墙内) + zoho自主域名邮箱</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                涨知识
              </span><span class="blog-gallery-tag">
                Jekyll
              </span><span class="blog-gallery-tag">
                静态博客
              </span></span></p></div></a></div><div class="blog-gallery-unit"><a href="/blogs/2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs" title="Nuxt默认会将所有vue文件使用的模块打包进最后的网站文件，所以最好不要在博客页渲染Markdown" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>如何减轻Nuxt打包生成的代码量</h4> <p class="blog-date"><span class="fa fa-calendar">
               2019-05-18
            </span></p> <p class="align-left"><span class="blog-gallery-desc">Nuxt默认会将所有vue文件使用的模块打包进最后的网站文件，所以最好不要在博客页渲染Markdown</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                涨知识
              </span><span class="blog-gallery-tag">
                Nuxt
              </span></span></p></div></a></div></div></div> <div id="comment"></div></section></div></main> <footer><p>Created with Nuxt.js <br>
    	Made by  
    	<a href="https://github.com/c53hzn" target="_blank" class="no-decor-link"><strong>Jenny HOU</strong> <i class="fa fa-github font-20"></i></a></p> <div class="go-top go-top-hidden"><div class="arrow"></div> <div class="stick"></div></div></footer></div></div></div><script>window.__NUXT__=function(s,a,n,l,e,t,p,r,o){return t[0]=l,t[1]=p,t[2]=r,{layout:"default",data:[{blog:{layout:n,title:"如何使用Nuxt建立个人博客",description:"Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面",tags:t,comments:!0,related_blog:[o,e],slug:a,content:'<p><h3> </h3><ul><li><a href=\"#_1\">前言</a></li><li><a href=\"#_Nuxt_9\">关于 Nuxt</a></li><li><a href=\"#_19\">我的个人网站需要实现什么功能？</a></li><li><a href=\"#_31\">我需要学会哪些技能？有什么好的教学资源？</a></li><ul><li><a href=\"#Youtube__35\">Youtube 教学视频</a></li><li><a href=\"#_57\">网络文章教程（日、英）</a></li></ul><li><a href=\"#_70\">我的网站构建过程</a></li><ul><li><a href=\"#_72\">项目结构</a></li><li><a href=\"#_CMS__API_112\">作为 CMS 作用的 API</a></li><ul><li><a href=\"#Markdown_114\">Markdown文件的写法</a></li><li><a href=\"#_136\">根据参数读取并返回数据</a></li></ul><li><a href=\"#_API__248\">从 API 读取数据并渲染到页面</a></li><li><a href=\"#_323\">生成静态页面</a></li><li><a href=\"#_360\">小插曲</a></li><ul><li><a href=\"#_362\">路由和内部链接</a></li><li><a href=\"#_370\">根目录</a></li></ul></ul><li><a href=\"#_382\">心得体会</a></li></ul></p>\n<h1><a id=\"_1\"></a>前言</h1>\n<p>更新日期：2020-03-18</p>\n<p>之前写的版本有点乱，想到哪写到哪，如果是路人从 Google 点进来，也许看不明白我写了些啥，所以我把文章重构了一下。</p>\n<p>我的网站从2018年3月17日至2019年5月5日期间用的是 Jekyll，主题叫 Hydejack，由 Github 自带的 Ruby 后台驱动。从2019年5月6日开始转为使用 Nuxt 生成的纯静态页面，主题是我自己设计的，没名字，本篇文章会讲述使用 Nuxt 设计博客网站的过程和要点。</p>\n<h1><a id=\"_Nuxt_9\"></a>关于 Nuxt</h1>\n<p>官网在<a href=\"https://zh.nuxtjs.org/guide/\">这里</a>。</p>\n<blockquote>\n<p>Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染( SSR ) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等优势。</p>\n</blockquote>\n<p>也就是说，如果你想做一个有后台的动态网站，可以用 Nuxt 直接部署到 Node 服务器上。</p>\n<p>如果你只是想做一个静态网站，则可以用 Nuxt 生成静态页面，然后把静态页面上传到 Github 或者任何支持静态页面托管服务的网站，本站就是这样做的。</p>\n<h1><a id=\"_19\"></a>我的个人网站需要实现什么功能？</h1>\n<p>我参考了 <code>Jekyll</code>、<code>Hexo</code>、<code>Hugo</code> 等静态网站生成工具，它们能够做到的，我希望我的网站也能做到。</p>\n<p>作为个人网站来说，能够写日志是最基本的，那么它就需要有以下的功能：</p>\n<ul>\n<li>文章列表页</li>\n<li>文章详情页（要能显示文章详情，有上一篇、下一篇按钮，并推荐相关文章）</li>\n<li>标签列表页</li>\n<li>标签下文章列表页</li>\n</ul>\n<p>然后再来几个独立页面，最好能有简历页、联络页，首页最好能推送最新文章，推送内容需包括文章标题、日期、标签、内容简介。</p>\n<h1><a id=\"_31\"></a>我需要学会哪些技能？有什么好的教学资源？</h1>\n<p><code>Node</code>、<code>Vue</code> 和 <code>NPM</code> 是最基本的，而设计网站 UI 就比较随缘了，除了渲染 Markdown 用的 CSS 是从外部导入的之外，其他的主要设计都是我自己完成的。本篇文章不会讲任何 Vue 模板的基础知识，包括渲染数据和页面交互等。而 Nuxt 方面的教学，我主要参考了以下的一些资源。</p>\n<h2><a id=\"Youtube__35\"></a>Youtube 教学视频</h2>\n<p>我在 Youtube 上搜了很多，最后完整地看了的，并且觉得有用的大概是以下这些</p>\n<ol>\n<li>\n<p>使用 Nuxt 生成静态网站<br>\n<a href=\"https://www.youtube.com/watch?v=pI2qHPI0ZpU\" title=\"Nuxt.js - Static Site Generator\"><img src=\"/img/blogs/2019-05-05/youtube05.jpg\" alt=\"youtube-img\"></a><br>\n这一个视频的主要内容是不使用外部资源，所有页面都用 <code>.vue</code> 的文件书写，最后生成静态网站。这样比较适合那种做好之后不会做什么大变动的网站，比如企业官网之类的。但博客文章不可能都用 <code>.vue</code> 文件来写，网站也不可能长久不更新，所以很显然不能直接用这个办法来做。</p>\n</li>\n<li>\n<p>使用 Nuxt (框架)和 <a href=\"https://www.storyblok.com/\">storyblok</a> (基于 api 提供内容的 CMS )建立个人博客<br>\n<a href=\"https://www.youtube.com/watch?v=Dc_5BpIB4X4\" title=\"The Front-End | Nuxt.js &amp; Storyblok - Building a Complete Blog\"><img src=\"/img/blogs/2019-05-05/youtube01.jpg\" alt=\"youtube-img\"></a>\n<a href=\"https://www.youtube.com/watch?v=UIh4P5rNjac\" title=\"Adding Storyblok CMS | Nuxt.js &amp; Storyblok - Building a Complete Blog\"><img src=\"/img/blogs/2019-05-05/youtube02.jpg\" alt=\"youtube-img\"></a>\n<a href=\"https://www.youtube.com/watch?v=Yq6Ddu_QAiY\" title=\"Storyblok Live Preview! | Nuxt.js &amp; Storyblok - Building a Complete Blog\"><img src=\"/img/blogs/2019-05-05/youtube03.jpg\" alt=\"youtube-img\"></a>\n<a href=\"https://www.youtube.com/watch?v=JHCKab2oS4s\" title=\"Final Touches &amp; Deploying the Blog | Nuxt.js &amp; Storyblok - Building a Complete Blog\"><img src=\"/img/blogs/2019-05-05/youtube04.jpg\" alt=\"youtube-img\"></a><br>\n这个系列的视频主要内容是使用 Nuxt 建立博客首页（文章列表页）、附属页面，建立页面导航路由，然后在博客详情页用 <code>Axios</code> 加载 api 传来的文章内容，最后生成静态网站。<br>\n这里有一点很重要的是，up 主的博客内容是托管在 <a href=\"https://www.storyblok.com/\">storyblok</a> 这个 CMS 上，不在电脑本地，也不是用 Markdown 来书写。除了 <a href=\"https://www.storyblok.com/\">storyblok</a> 之外还有 <a href=\"https://www.contentful.com/\">contentful</a> 等提供内容管理的网站，也能达到相同的效果。<br>\n但是对于像我这样从 Jekyll 转过来的人来说，还是想找找能继续用 Markdown 写文章的办法。这里的“使用 CMS 的 api 来提供博客内容”的思路值得我参考。如果不使用外部商业 CMS 服务，我自己能不能在本地搭建一个类似的服务呢？只要有提供内容的 api，我就可以跟 up 主一样成功生成静态网站了。</p>\n</li>\n<li>\n<p>手把手教你在 Nuxt 项目中使用 serverMiddleware<br>\n<a href=\"https://www.youtube.com/watch?v=j-3RwvWZoaU\" title=\"Why You Should Learn Server Middleware with Nuxt.js! A step-by-step tutorial!\"><img src=\"/img/blogs/2019-05-05/youtube06.jpg\" alt=\"youtube-img\"></a><br>\n这个视频教了一下作为服务端渲染的 Nuxt 里面配置 <code>serverMiddleware</code> 的 api 的简单过程，以及 api 的服务端代码怎么写。如果我是做动态网站，那么使用这个 api 来解析我的 Markdown 文件来提供文章内容，网站就可以直接上线了。<br>\n由于我是要做纯静态网站，所以用不到 serverMiddleware，但是它这里配置后台 api 的代码对我来说很有用，我们可以不用 serverMiddleware，而是单独开一个 api 的服务出来，解析 Markdown 文件，返回 json，这样就等于有了一个自己的 CMS 啦！</p>\n</li>\n</ol>\n<h2><a id=\"_57\"></a>网络文章教程（日、英）</h2>\n<p>中文世界里的文字教程也是有的，但是英文和日文的更能学到东西。</p>\n<ol>\n<li>\n<p><strong>使用 Nuxt + Markdown 创建个人博客（英文）</strong><a href=\"https://marinaaisa.com/blog/blog-using-vue-nuxt-markdown\">链接</a><br>\n作者成功实现了在 Nuxt 单一服务下解析 Markdown 文件的效果，但是她的做法竟然需要事先准备好一个 js 文件作为文章列表，每新增一个 Markdown 文件，就在 js 文件里面<strong>手动</strong>添加一篇文章的标题和链接，这样才能做到更新。而我这边希望网站可以<strong>自动</strong>识别新增的文章，所以她的这个办法可能不适合我。<br>\n作者也很大方地把网站源码发出来了，她的 repo 在 <a href=\"https://github.com/marinaaisa/nuxt-markdown-blog-starter\">这里</a>。<br>\n作者的页面设计和排版很符合国外网站的审美，简洁、大气、好看，不过博客文章没有标签系统，算是一个小的缺憾吧。</p>\n</li>\n<li>\n<p><strong>使用 Nuxt 重构网站（日文）</strong><a href=\"https://blog.nakamu.life/posts/replace-tech-blog\">链接</a><br>\n找教程居然找到日文的，我也是很佩服我自己。作者的文字不难懂，搭建流程和技术要点解释得也很清楚。作者是用 <a href=\"https://www.contentful.com/\">contentful</a> 来提供内容的，这样就和前面的 Youtube 教程重复了。但是他的 UI 设计得很好，完全不像一般日本人的风格，非常值得参考。<br>\n作者自己的技术博客用的是 Nuxt 搭建的，链接在 <a href=\"https://marinaaisa.com/blog/blog-using-vue-nuxt-markdown\">这里</a> 此外还有一个用 Gatsby(React) 设计的生活博客，链接在 <a href=\"https://enjoyhk.nakamu.life/\">这里</a> 可惜我之前学的那点 React 都忘光了，不然也可以参考这个。</p>\n</li>\n</ol>\n<h1><a id=\"_70\"></a>我的网站构建过程</h1>\n<h2><a id=\"_72\"></a>项目结构</h2>\n<pre><code>myblog\n├─ api    //☆手动建立这个文件夹☆\n│   ├─ blogs    //需要api解析的Markdown文件夹\n│   │   ├─ 2019-05-05-set-up-static-blog-using-nuxt.md\n│   │   ├─ 2017-05-28-hao123-issue.md\n│   │   └─ ...\n│   └─ index.js //api的入口，默认路径http://127.0.0.1:4000\n├─ components\n│   ├─ Footer.vue\n│   └─ Navigation.vue\n├─ dist        //☆最后生成的静态文件在这里，上传到 GitHub 就行啦☆\n├─ layouts\n│   ├─ default.vue //Navigation + Nuxt(主要内容) + Footer\n│   └─ error.vue //动态部署时会显示这个，但静态网页找不到时会去服务器（GitHub）的404页\n├─ pages\n│   ├─ blogs\n│   │   ├─ tag\n│   │   │   ├─ _tag.vue  //动态渲染标签下的文章列表\n│   │   │   │            eg =&gt; /blogs/tag/aaa.html\n│   │   │   └─ index.vue //文章标签列表页 =&gt; /blogs/tag.html\n│   │   ├─ _slug.vue //动态渲染文章详情页\n│   │   │                 eg =&gt; /blogs/2019-05-05-set-up-static-blog-using-nuxt.html\n│   │   └─ index.vue //文章列表页 =&gt; /blogs.html\n│   ├─ resume.vue\n│   └─ index.vue     //网站入口 =&gt; /index.html\n├─ static\n│   ├─ img  //引用路径 /img/home/bg.jpg\n│   │   └─ home\n│   │       └─ bg.jpg\n│   ├─ js  //引用路径 /js/jquery.js\n│   │   └─ jquery.js\n│   ├─ favicon.ico  //网站图标 =&gt; /favicon.ico\n│   └─ styles.css   //公用css =&gt; /styles.css\n├─ nuxt.config.js  //nuxt网站整体设置\n└─ ...\n</code></pre>\n<h2><a id=\"_CMS__API_112\"></a>作为 CMS 作用的 API</h2>\n<h3><a id=\"Markdown_114\"></a>Markdown文件的写法</h3>\n<p>基本上跟原先 Jekyll 里用的 Markdown 文件写法一样，但是为了能添加“相关文章”功能，我在 Markdown 里新增了一个属性 <code>related_blog</code>，里面填写关联的文章的不包含扩展名的文件名即可。</p>\n<pre><code>---\nlayout: post\ntitle: 如何使用Nuxt建立个人博客\ndescription: Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面\ntags: [涨知识,Nuxt,静态博客]\ncomments: true\nrelated_blog: [2018-03-28-set-up-static-blog]\n---\n# 标题一\n\nasdf\n\n# 标题二\n\nasdf\n</code></pre>\n<h3><a id=\"_136\"></a>根据参数读取并返回数据</h3>\n<p>在这个 api 里面，我直接把读取的 Markdown 内容转化成了 HTML，这样可以减轻最后生成的网站文件大小，原因可见<a href=\"/blogs/2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs\">这篇文章</a>。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"express\"</span>);\n<span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"fs\"</span>);\n<span class=\"hljs-keyword\">var</span> fm = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'front-matter'</span>);\n<span class=\"hljs-keyword\">var</span> app = express();\n<span class=\"hljs-keyword\">var</span> hljs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'highlight.js'</span>);\n<span class=\"hljs-keyword\">var</span> markdownIt = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'markdown-it'</span>);\n<span class=\"hljs-keyword\">var</span> md = markdownIt({\n  <span class=\"hljs-attr\">html</span>:         <span class=\"hljs-literal\">false</span>,        <span class=\"hljs-comment\">// 在源码中启用 HTML 标签</span>\n  xhtmlOut:     <span class=\"hljs-literal\">false</span>,        <span class=\"hljs-comment\">// 使用 '/' 来闭合单标签 （比如 &lt;br /&gt;）。</span>\n  breaks:       <span class=\"hljs-literal\">false</span>,        <span class=\"hljs-comment\">// 转换段落里的 '\\n' 到 &lt;br&gt;。</span>\n  langPrefix:   <span class=\"hljs-string\">'language-'</span>,  <span class=\"hljs-comment\">// 给围栏代码块的 CSS 语言前缀。对于额外的高亮代码非常有用。</span>\n  linkify:      <span class=\"hljs-literal\">false</span>,        <span class=\"hljs-comment\">// 将类似 URL 的文本自动转换为链接。</span>\n  typographer:  <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">quotes</span>: <span class=\"hljs-string\">'“”‘’'</span>,\n  <span class=\"hljs-attr\">highlight</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">str, lang</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">return</span> hljs.highlight(lang, str).value;\n      } <span class=\"hljs-keyword\">catch</span> (__) {}\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>; <span class=\"hljs-comment\">// 使用额外的默认转义</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> singleBlog = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fullPath, slug, isContentRequired</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> blog = {};\n  <span class=\"hljs-keyword\">var</span> content = fm(fs.readFileSync(fullPath, <span class=\"hljs-string\">\"utf8\"</span>));\n  blog = content.attributes;\n  blog.slug = slug;\n  <span class=\"hljs-keyword\">if</span> (isContentRequired) {\n    blog.content = md.render(content.body);\n  }\n  <span class=\"hljs-keyword\">return</span> blog;\n}\n\napp.get(<span class=\"hljs-string\">\"/blogs\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req, res</span>) </span>{\n  <span class=\"hljs-comment\">// allow cross orign access, because api and Nuxt are served separately</span>\n  res.header(<span class=\"hljs-string\">'Access-Control-Allow-Origin'</span>, <span class=\"hljs-string\">'*'</span>);\n  <span class=\"hljs-keyword\">var</span> path = __dirname + <span class=\"hljs-string\">'\\\\blogs'</span>;\n  <span class=\"hljs-keyword\">var</span> files = fs.readdirSync(path);\n  <span class=\"hljs-keyword\">var</span> json = {};<span class=\"hljs-comment\">// result to be returned</span>\n  <span class=\"hljs-keyword\">var</span> qSlug = req.query.slug || <span class=\"hljs-string\">\"\"</span>;\n  <span class=\"hljs-keyword\">var</span> qTag = req.query.tag || <span class=\"hljs-string\">\"\"</span>;\n  <span class=\"hljs-keyword\">if</span> (qSlug) {<span class=\"hljs-comment\">// with blog slug query</span>\n    json = singleBlog(path+<span class=\"hljs-string\">\"\\\\\"</span>+qSlug+<span class=\"hljs-string\">\".md\"</span>, qSlug, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k = <span class=\"hljs-number\">0</span>; k &lt; files.length; k++) {<span class=\"hljs-comment\">// add prev and next blog</span>\n      <span class=\"hljs-keyword\">if</span> (qSlug == files[k].replace(<span class=\"hljs-string\">\".md\"</span>, <span class=\"hljs-string\">\"\"</span>)) {\n        <span class=\"hljs-keyword\">if</span> (k === <span class=\"hljs-number\">0</span>) {\n          json.next = files[k+<span class=\"hljs-number\">1</span>].replace(<span class=\"hljs-string\">\".md\"</span>,<span class=\"hljs-string\">\"\"</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (k === files.length<span class=\"hljs-number\">-1</span>) {\n          json.prev = files[k<span class=\"hljs-number\">-1</span>].replace(<span class=\"hljs-string\">\".md\"</span>,<span class=\"hljs-string\">\"\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          json.prev = files[k<span class=\"hljs-number\">-1</span>].replace(<span class=\"hljs-string\">\".md\"</span>,<span class=\"hljs-string\">\"\"</span>);\n          json.next = files[k+<span class=\"hljs-number\">1</span>].replace(<span class=\"hljs-string\">\".md\"</span>,<span class=\"hljs-string\">\"\"</span>);\n        }\n      }\n    }\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (qTag) {<span class=\"hljs-comment\">// with tag query</span>\n    <span class=\"hljs-keyword\">if</span> (qTag == <span class=\"hljs-string\">\"all_tags\"</span>) {<span class=\"hljs-comment\">// returns list of all available tags</span>\n      json.tags = {};\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; files.length; i++) {\n        <span class=\"hljs-keyword\">let</span> blogPost = singleBlog(path+<span class=\"hljs-string\">\"\\\\\"</span>+files[i], files[i].replace(<span class=\"hljs-string\">\".md\"</span>, <span class=\"hljs-string\">\"\"</span>));\n        <span class=\"hljs-keyword\">let</span> tags = blogPost.tags || [<span class=\"hljs-string\">'none'</span>];\n        <span class=\"hljs-keyword\">let</span> entry = {\n          <span class=\"hljs-attr\">title</span>: blogPost.title,\n          <span class=\"hljs-attr\">slug</span>: blogPost.slug\n        };\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; tags.length; j++) {\n          <span class=\"hljs-keyword\">if</span> (json.tags[tags[j]]) {\n            json.tags[tags[j]].unshift(entry);\n          } <span class=\"hljs-keyword\">else</span> {\n            json.tags[tags[j]] = [];\n            json.tags[tags[j]].unshift(entry);\n          }\n        }\n      }\n    } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">// returns blog list of specific tag</span>\n      json.blogs = [];\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; files.length; i++) {\n        <span class=\"hljs-keyword\">let</span> blogPost = singleBlog(path+<span class=\"hljs-string\">\"\\\\\"</span>+files[i], files[i].replace(<span class=\"hljs-string\">\".md\"</span>, <span class=\"hljs-string\">\"\"</span>));\n        <span class=\"hljs-keyword\">let</span> tags = blogPost.tags || [<span class=\"hljs-string\">'none'</span>];\n        <span class=\"hljs-keyword\">let</span> entry = {\n          <span class=\"hljs-attr\">title</span>: blogPost.title,\n          <span class=\"hljs-attr\">slug</span>: blogPost.slug\n        };\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; tags.length; j++) {\n          <span class=\"hljs-keyword\">if</span> (tags[j] == qTag) {\n            json.blogs.unshift(blogPost);\n          }\n        }\n      }\n    }\n  } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">//without requirement, returns list of all blogs</span>\n    json.blogs = [];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; files.length; i++) {\n      <span class=\"hljs-keyword\">let</span> blogPost = singleBlog(path+<span class=\"hljs-string\">\"\\\\\"</span>+files[i], files[i].replace(<span class=\"hljs-string\">\".md\"</span>, <span class=\"hljs-string\">\"\"</span>));\n      json.blogs.unshift(blogPost);\n    }\n  }\n  res.send(json);\n});\n<span class=\"hljs-comment\">/* nuxt is using port 3000, so choose another one */</span>\napp.listen(<span class=\"hljs-number\">4000</span>, () =&gt; {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"express server running at http://127.0.0.1:4000\"</span>)\n});\n</code></pre>\n<h2><a id=\"_API__248\"></a>从 API 读取数据并渲染到页面</h2>\n<p>在 <code>/blogs/index.vue</code> 页面用 <code>asyncData</code> 方法来加载数据</p>\n<p>记得要先 <code>import axios from 'axios'</code>，然后</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">layout</span>: <span class=\"hljs-string\">\"default\"</span>,\n  asyncData(context) {\n    <span class=\"hljs-keyword\">return</span> axios.get(<span class=\"hljs-string\">'http://127.0.0.1:4000/blogs'</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> { \n        <span class=\"hljs-attr\">blogs</span>: res.data.blogs,\n        <span class=\"hljs-attr\">baseURL</span>: context.app.router.options.base\n      };\n    })\n  }\n</code></pre>\n<p>在 <code>/blogs/_slug.vue</code> 页面同样用 <code>asyncData</code> 方法来加载数据</p>\n<pre><code class=\"language-javascript\">asyncData(context) {\n  <span class=\"hljs-keyword\">return</span> axios.get(<span class=\"hljs-string\">'http://127.0.0.1:4000/blogs?slug='</span>+context.params.slug).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">let</span> blog = res.data;\n    <span class=\"hljs-keyword\">let</span> space = [];\n    <span class=\"hljs-keyword\">let</span> related = blog.related_blog;\n    <span class=\"hljs-keyword\">if</span> (!related) {\n      related = [];\n    }\n    <span class=\"hljs-keyword\">var</span> requests = [];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; related.length; i++) {\n      <span class=\"hljs-keyword\">let</span> blogJson = axios.get(<span class=\"hljs-string\">'http://127.0.0.1:4000/blogs?slug='</span>+related[i])\n      .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {<span class=\"hljs-comment\">// res.data is json</span>\n        <span class=\"hljs-keyword\">let</span> temp = res.data;\n        <span class=\"hljs-keyword\">if</span> (temp) {\n          <span class=\"hljs-keyword\">delete</span> res.data.content;\n          res.data.date = res.data.slug.substring(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>);\n          <span class=\"hljs-keyword\">return</span> res.data;\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">return</span> {};\n        }\n       });\n       requests.push(blogJson);\n    };\n    <span class=\"hljs-keyword\">if</span> (requests.length) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(requests).then(<span class=\"hljs-function\"><span class=\"hljs-params\">values</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">let</span> related_results = [];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-number\">0</span>; m &lt; values.length; m++) {\n          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">JSON</span>.stringify(values[m]) != <span class=\"hljs-string\">\"{}\"</span>) {\n            related_results.push(values[m])\n          }\n        }\n        <span class=\"hljs-keyword\">return</span> {\n          <span class=\"hljs-attr\">blog</span>: blog,\n          <span class=\"hljs-attr\">tags</span>: blog.tags || [<span class=\"hljs-string\">'none'</span>],\n          <span class=\"hljs-attr\">date</span>: context.params.slug.substring(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">10</span>),\n          <span class=\"hljs-attr\">relatedBlog</span>: related_results,\n        }\n      })\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">blog</span>: blog,\n        <span class=\"hljs-attr\">tags</span>: blog.tags || [<span class=\"hljs-string\">'none'</span>],\n        <span class=\"hljs-attr\">date</span>: context.params.slug.substring(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">10</span>),\n        <span class=\"hljs-attr\">relatedBlog</span>: [],\n        <span class=\"hljs-attr\">baseURL</span>: context.app.router.options.base,\n      };\n    } \n  })\n}\n</code></pre>\n<p>标签页等等就不赘述了。</p>\n<h2><a id=\"_323\"></a>生成静态页面</h2>\n<p>生成静态页面的命令是 <code>npm run generate</code>，如果不做特殊设置的话，系统只会为 <code>pages</code> 文件夹及子文件夹里所有不是以下划线开头的 <code>.vue</code> 文件生成页面，也就是说，那些用 <code>_slug.vue</code> 和 <code>_tag.vue</code> 来动态获取的页面不会生成相应的静态页面，而如果想生成的话，就需要在 <code>nuxt.config.js</code> 这个文件里面设置要动态生成的 <code>routes</code>。</p>\n<p>并且 Nuxt 默认是为每个页面生成各自的文件夹，在文件夹里生成 <code>index.html</code> 文件来访问，也就是说，本篇文章可以用 <code>/blogs/2019-05-05-set-up-static-blog-using-nuxt/</code> 来访问，也可以用 <code>2019-05-05-set-up-static-blog-using-nuxt/index.html</code> 来访问。但是想象一下这个文件夹的数量，还是取消吧！</p>\n<pre><code class=\"language-javascript\">generate: {\n  <span class=\"hljs-attr\">subFolders</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">//if true, each page or post will have their own folder</span>\n  routes: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> blogs = axios.get(<span class=\"hljs-string\">'http://127.0.0.1:4000'</span>)\n    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {<span class=\"hljs-comment\">// res.data is array</span>\n      <span class=\"hljs-keyword\">return</span> res.data.blogs.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">blog</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">return</span> {\n          <span class=\"hljs-attr\">route</span>: <span class=\"hljs-string\">'/blogs/'</span> + blog.slug,\n          <span class=\"hljs-attr\">payload</span>: blog\n        }\n      })\n    })\n    <span class=\"hljs-keyword\">let</span> tags = axios.get(<span class=\"hljs-string\">'http://127.0.0.1:4000?tag=all_tags'</span>)\n    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {<span class=\"hljs-comment\">// res.data is object</span>\n      <span class=\"hljs-keyword\">let</span> tags = <span class=\"hljs-built_in\">Object</span>.keys(res.data.tags);\n      <span class=\"hljs-keyword\">return</span> tags.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">tag</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">return</span> {\n          <span class=\"hljs-attr\">route</span>: <span class=\"hljs-string\">'/blogs/tag/'</span> + tag,\n          <span class=\"hljs-attr\">payload</span>: tag\n        };\n      });\n    })\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all([blogs, tags]).then(<span class=\"hljs-function\"><span class=\"hljs-params\">values</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> [...values[<span class=\"hljs-number\">0</span>], ...values[<span class=\"hljs-number\">1</span>]]\n    })\n  },\n  ...\n}\n</code></pre>\n<h2><a id=\"_360\"></a>小插曲</h2>\n<h3><a id=\"_362\"></a>路由和内部链接</h3>\n<p>本来页面导航栏和各种链接应该要使用 <code>&lt;nuxt-link/&gt;</code> 标签的，这样就可以用Nuxt的路由机制，加快访问速度。</p>\n<p>但是它有一个问题是，在最终生成的静态网站上使用路由访问的时候，页面仍然会去请求 <code>127.0.0.1:4000</code> 上的内容，可是这时候 api 已经关闭了，请求失败之后页面就会来个“Network error”，可是如果使用URL去访问，又是可以加载出内容的。</p>\n<p>所以我不得不忍痛割爱，把所有 <code>&lt;nuxt-link/&gt;</code>的链接都换成了普通的 <code>&lt;a&gt;&lt;/a&gt;</code> 标签的链接，这样静态网站就可以正常使用了。</p>\n<h3><a id=\"_370\"></a>根目录</h3>\n<p>如果你的网站不在服务器的根目录里，而是像 <code>xxx.github.io/myproject</code> 这样的路径的话，就需要在 <code>nuxt.config.js</code> 里面设置</p>\n<pre><code class=\"language-javascript\">router: {\n  <span class=\"hljs-attr\">base</span>: <span class=\"hljs-regexp\">/myproject/</span>\n}\n</code></pre>\n<p>然后不管是动态还是静态的网站应该都是正确的链接了。</p>\n<h1><a id=\"_382\"></a>心得体会</h1>\n<p>前前后后花了两个多星期，我的博客终于有了新面貌，然而在这个过程中最惊喜的还是 Youtube，想找什么样的教学视频都有。</p>\n<p>而且它自动生成的字幕非常有用，各个国家千奇百怪的口音竟然都能识别出来，即使不是100%匹配，也能让我这个非英语母语的人跟上视频博主的思路。</p>\n<p>在这里给 Youtube 点个赞！</p>\n',prev:"2018-12-21-Korean-drama-memories-of-the-alhambra-n-feel-good-to-die",next:e},tags:t,date:"2019-05-05",relatedBlog:[{layout:n,title:"如何搭建静态个人博客",description:"我的个人博客 = Github代码托管 + Jekyll模板 + Godaddy域名 + Cloudflare安全认证 + disqus评论系统 + 反向代理访问disqus(墙内) + zoho自主域名邮箱",tags:[l,"Jekyll",r],author:"author1",comments:!0,related_blog:[a],canonical_url:"http://hyde.getpoole.com/2012/02/06/whats-jekyll/",slug:o,prev:"2017-05-28-hao123-issue",next:"2018-11-08-product-landing-page-with-scroll-effects",date:"2018-03-28"},{layout:n,title:"如何减轻Nuxt打包生成的代码量",description:"Nuxt默认会将所有vue文件使用的模块打包进最后的网站文件，所以最好不要在博客页渲染Markdown",related_blog:[a],tags:[l,p],comments:!0,slug:e,prev:a,next:"2019-05-25-takarazuka-musical",date:"2019-05-18"}],baseURL:"/",ui_str:{to_prev:"上一篇",to_next:"下一篇",related_posts:"相关文章"}}],error:null,serverRendered:!0}}(0,"2019-05-05-set-up-static-blog-using-nuxt","post","涨知识","2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs",Array(3),"Nuxt","静态博客","2018-03-28-set-up-static-blog")</script><script src="/_nuxt/859ccb1ab7a988ba93fe.js" defer></script><script src="/_nuxt/dce006513b8e822894f0.js" defer></script><script src="/_nuxt/e538c0d34daa29c0b6a1.js" defer></script><script src="/_nuxt/c50eecc5d001f3cf9b3f.js" defer></script>
  </body>
</html>
