<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">如何使用Nuxt建立个人博客 | Jenny的小站</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面"><link data-n-head="true" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="true" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Gugi"><link data-n-head="true" rel="stylesheet" href="/styles.css"><link data-n-head="true" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css"><link data-n-head="true" rel="stylesheet" href="/highlight.js.css"><base href="/"><link rel="preload" href="/_nuxt/61bcbbd34eb29ae7ae0d.js" as="script"><link rel="preload" href="/_nuxt/ec0b83a3fb195aad8df5.js" as="script"><link rel="preload" href="/_nuxt/fb1304f7c79d4074ba22.js" as="script"><link rel="preload" href="/_nuxt/33ef648db803cfae2c04.js" as="script"><style data-vue-ssr-id="17cfdfa9:0 1b738458:0 498b36b5:0 31ba154a:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#3b8070;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}nav[data-v-196bf44f]{position:fixed;top:0;left:0;right:0;bottom:0;height:40px;box-shadow:0 0 1px 0 rgba(0,0,0,.6);z-index:9999}.nav-wrap[data-v-196bf44f],nav[data-v-196bf44f]{background:inherit}.nav-wrap[data-v-196bf44f]{margin:0 auto;width:800px;height:100%;display:flex;justify-content:space-between}header[data-v-196bf44f]{font-family:Gugi,cursive;margin:0 0 0 10px;height:100%;z-index:2}.nav-ul[data-v-196bf44f],header h2[data-v-196bf44f]{margin:0;height:100%}header a[data-v-196bf44f]{text-decoration:none}header a[data-v-196bf44f]:active,header a[data-v-196bf44f]:visited{color:inherit}.font-impact[data-v-196bf44f]{font-family:Impact}.nav-ul[data-v-196bf44f]{list-style:none;text-align:right;display:flex;justify-content:center;z-index:1}.nav-link[data-v-196bf44f]{margin-right:20px;height:100%;text-decoration:none}.nav-link[data-v-196bf44f]:last{margin-right:10px}.nav-link[data-v-196bf44f]:active{color:inherit}.nav-link li[data-v-196bf44f],header h2[data-v-196bf44f]{color:#000;height:100%;line-height:40px}.nav-link li[data-v-196bf44f]:hover{color:grey}.nav-link[data-v-196bf44f]:visited{color:inherit}.nuxt-link-active[data-v-196bf44f]{border-bottom:1px solid #000}.nav-mask[data-v-196bf44f]{height:40px;background:inherit;z-index:0}.body-mask[data-v-196bf44f],.nav-mask[data-v-196bf44f]{position:fixed;width:100%}.body-mask[data-v-196bf44f]{height:0;transition:height .8s;background:rgba(0,0,0,.5)}.body-mask-visible[data-v-196bf44f]{height:100%}.nav-btn[data-v-196bf44f]{width:40px;height:40px;display:none;z-index:2}.bar[data-v-196bf44f]{width:70%;height:25%;text-align:center;border-bottom:2px solid #000}.bar[data-v-196bf44f]:last-child{border:none}@media (max-width:425px){nav[data-v-196bf44f]{box-shadow:none}.nav-wrap[data-v-196bf44f]{width:100%}.nav-mask[data-v-196bf44f]{border-bottom:1px solid grey;z-index:1}.nav-ul[data-v-196bf44f]{position:fixed;margin-top:40px;padding:0;width:100%;height:auto;-webkit-transform:translateY(-100%);transform:translateY(-100%);text-align:left;background:#fff;transition:-webkit-transform .8s;transition:transform .8s;transition:transform .8s,-webkit-transform .8s;display:block;overflow:hidden;z-index:0}.nav-mobile[data-v-196bf44f]{-webkit-transform:translateY(0);transform:translateY(0)}.nav-link[data-v-196bf44f]{margin:0 10px;padding:12px 0 0;height:auto;line-height:20px;border-bottom:1px solid #000;display:block}.nav-link[data-v-196bf44f]:last-child{margin-bottom:10px}.nav-link li[data-v-196bf44f]{margin-left:10px;margin-right:10px;width:auto;line-height:20px}.nav-btn[data-v-196bf44f]{display:block}}.blog-desc{margin:10px;padding:10px;color:#666;background-color:rgba(0,0,0,.025)}.youtube-img{position:relative;display:inline-block}.youtube-img:before{width:40%;height:40%;border-radius:25%;background:red}.youtube-img:after,.youtube-img:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;margin:auto;transition:opacity .2s}.youtube-img:after{width:0;height:0;border-top:10px solid transparent;border-left:20px solid #fff;border-bottom:10px solid transparent}.youtube-img:hover:after,.youtube-img:hover:before{opacity:.7;transition:opacity .2s}footer[data-v-4bfe094d]{padding:20px;border-top:1px solid rgba(0,0,0,.6)}p[data-v-4bfe094d]{margin:0 auto;font-size:14px;text-align:center}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="container"><nav data-v-196bf44f><div class="nav-wrap" data-v-196bf44f><header data-v-196bf44f><a href="/" class="no-decor" data-v-196bf44f><h2 data-v-196bf44f>Jenny's blog</h2></a></header> <div class="nav-btn" data-v-196bf44f><div class="bar" data-v-196bf44f></div> <div class="bar" data-v-196bf44f></div> <div class="bar" data-v-196bf44f></div> <div class="bar" data-v-196bf44f></div></div> <div class="nav-mask" data-v-196bf44f></div> <div class="body-mask" data-v-196bf44f></div> <ul class="nav-ul" data-v-196bf44f><a href="/resume" class="nav-link" data-v-196bf44f><li data-v-196bf44f>Resume</li></a><a href="/blogs" class="nav-link nuxt-link-active" data-v-196bf44f><li data-v-196bf44f>Blogs</li></a></ul></div></nav> <main><div><h1>如何使用Nuxt建立个人博客</h1> <p class="blog-date">2019-05-05</p> <p class="blog-date">
    Tags: 
    <span class="blog-tag"><a href="/blogs/tag/涨知识">涨知识</a></span><span class="blog-tag"><a href="/blogs/tag/Nuxt">Nuxt</a></span></p> <div class="blog-desc">Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面</div> <div class="markdown-body"><h2 id="nuxt是什么？">Nuxt是什么？</h2>
<blockquote>
<p>Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染(SSR) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等优势。</p>
</blockquote>
<h2 id="为什么要从jekyll转成nuxt？">为什么要从Jekyll转成Nuxt？</h2>
<p>其实也没啥原因，就是想自己做个网站试试。</p>
<p>之前用的Jekyll模板是别人做的，自己就算想做点个性化设置也无从下手。</p>
<p>况且Jekyll是用Ruby写的，自从上次尝试安装Ruby失败之后，我就对Jekyll失望了。</p>
<p>因为没能安装Ruby，我也从来没能在本机上预览我的博客，只能是部署到GitHub之后才能看到成果，所以就更加失望了。</p>
<p>之前某大佬推荐说，可以试着用Nuxt做网站，因为Nuxt是基于Vue的框架，而我正好除了Vue之外啥也不会，所以应该适合我。</p>
<p>于是就开始整了。</p>
<h2 id="准备工作和建立博客的探索">准备工作和建立博客的探索</h2>
<p>首先得装vue-cli，有vue-cli之后起一个Nuxt示例项目，然后放着不动。</p>
<p>在实际开始做事之前，我先看了以下的Youtube教学视频，每一个都翻来覆去看了两三遍</p>
<p>Youtube视频教程：<strong>使用Nuxt(框架)和storyblok(基于api提供内容的CMS)建立个人博客</strong></p>
<p><a target="_blank" href="https://www.youtube.com/watch?v=Dc_5BpIB4X4" title="The Front-End | Nuxt.js & Storyblok - Building a Complete Blog"><span class="youtube-img"><img src="https://i.ytimg.com/vi/Dc_5BpIB4X4/default.jpg" alt="youtube-img"></span></a>
<a target="_blank" href="https://www.youtube.com/watch?v=UIh4P5rNjac" title="Adding Storyblok CMS | Nuxt.js & Storyblok - Building a Complete Blog"><span class="youtube-img"><img src="https://i.ytimg.com/vi/UIh4P5rNjac/default.jpg" alt="youtube-img"></span></a>
<a target="_blank" href="https://www.youtube.com/watch?v=Yq6Ddu_QAiY" title="Storyblok Live Preview! | Nuxt.js & Storyblok - Building a Complete Blog"><span class="youtube-img"><img src="https://i.ytimg.com/vi/Yq6Ddu_QAiY/default.jpg" alt="youtube-img"></span></a>
<a target="_blank" href="https://www.youtube.com/watch?v=JHCKab2oS4s" title="Final Touches & Deploying the Blog | Nuxt.js & Storyblok - Building a Complete Blog"><span class="youtube-img"><img src="https://i.ytimg.com/vi/JHCKab2oS4s/default.jpg" alt="youtube-img"></span></a></p>
<p>视频的主要内容是使用Nuxt建立博客首页（文章列表页）、附属页面，建立页面导航路由，然后在博客详情页用Axios加载api传来的文章内容，最后生成静态网站。</p>
<p>除了storyblok之外还有contentful等提供内容管理的网站，但是我不想依赖外部内容资源，也不想注册这些网站，于是就只是照着视频先起了个项目，写了些components和layout，然后建立了几个page。</p>
<p>其实也就三个：index.vue, about.vue, blogs.vue。</p>
<p>然后发现了另外一个Youtube视频教程：<strong>使用Nuxt生成静态网站</strong><br><a target="_blank" href="https://www.youtube.com/watch?v=pI2qHPI0ZpU" title="Nuxt.js - Static Site Generator"><span class="youtube-img"><img src="https://i.ytimg.com/vi/pI2qHPI0ZpU/default.jpg" alt="youtube-img"></span></a></p>
<p>这一个视频的主要内容是不使用外部资源，博客文章页也用.vue的文件书写，最后生成静态网站。</p>
<p>但是我不想专门给每一篇文章都开一个.vue的文件，这样没法在其他地方复用，也不能从别的项目导入Markdown文章。</p>
<p>于是我在google上搜索如何让Nuxt使用Markdown文件作为资源生成静态博客，然后找到一个Nuxt官方团队的github issue<br><a target="_blank" href="https://github.com/nuxt/nuxt.js/issues/396">Using markdown as articles?</a></p>
<p>中间有一楼说自己在Nuxt项目之外开了个api，以作返回Markdown文章内容之用，而楼内有个Nuxt官方成员回复说，可能考虑在Nuxt项目内添加一个叫作“serverMiddleware”的东西，这样就不用去另外开api来返回文章内容了。</p>
<p>这个issue是2017年的，我希望这么久的时间足够他们添加这个feature，于是又去搜“Nuxt serverMiddleware”，果然有惊喜。</p>
<p>然后我又看了这个Youtube视频：<strong>手把手教你在Nuxt项目中使用serverMiddleware</strong><br><a target="_blank" href="https://www.youtube.com/watch?v=j-3RwvWZoaU" title="Why You Should Learn Server Middleware with Nuxt.js! A step-by-step tutorial!"><span class="youtube-img"><img src="https://i.ytimg.com/vi/j-3RwvWZoaU/default.jpg" alt="youtube-img"></span></a></p>
<p>这个视频教了一下serverMiddleware的api路径配置，以及api的服务端代码怎么写。</p>
<p>这个api主要是作为一个express的Node服务器，可以指定它解析特定文件夹，并返回JSON，这样就完成了一个简易的api。由于Nuxt集成了express，我们可以直接配置serverMiddleware，马上就能使用。</p>
<p>于是我在项目内新增一个api的文件夹，里面摆放我旧博客里的Markdown文章，然后用api去做解析。</p>
<p>但是这样也有一个问题，api的服务端代码还没完全写好的时候，需要经常中断进程，修改完代码之后再重新开启。可是npm run dev一次就要好几分钟，而我可能就只是改了几个变量名，这样实在是太低效了。</p>
<p>而且在npm run generate生成静态网站的时候，如果这个api没有处于运行状态，是无法返回文章内容的。可是如果这边开一个终端运行开发模式，那边又开一个终端生成静态页面的话，两边都会报很多错，一行一行的红色警告吓死人。</p>
<p>于是我只好放弃serverMiddleware，让这个api单独去运行。</p>
<p>Nuxt项目在开发模式下是在localhost:3000上运行，而这个api则是在127.0.0.1:4000上，在项目运行开发模式之前先把api启动，调试完了关闭开发模式，然后生成静态页面，完了之后再把api关掉。</p>
<p>这样就成了。</p>
<h2 id="生成静态页面">生成静态页面</h2>
<p>说到生成静态页面，在默认情况下，/pages/index.vue会成为根目录下的首页，而用户在<code>/pages</code>文件夹下新建了多少个.vue文件，到时候就会在根目录下生成多少个文件夹，文件夹名就是原本的.vue文件名，而文件夹里则是一个index.html。</p>
<p>差不多像这样：    </p>
<pre><code>/pages/index<span class="hljs-selector-class">.vue</span> => /index<span class="hljs-selector-class">.html</span>  
/pages/about<span class="hljs-selector-class">.vue</span> => /about/index<span class="hljs-selector-class">.html</span>
/pages/contact<span class="hljs-selector-class">.vue</span> => /contact/index<span class="hljs-selector-class">.html</span>    </code></pre><p>但是这样会多出好多文件夹，最终生成的网站结构总感觉不太明晰。这个时候就需要到/nuxt.config.js里面做总配置，把subFolders设置为false即可。    </p>
<pre><code class="language-javascript">    <span class="hljs-keyword">module</span><span class="hljs-variable">.exports</span> = {
        ...
        <span class="hljs-keyword">generate</span>: {
            ...
            subFolders: false
            ...
        }
        ...
    }</code></pre>
<p>这样配置后生成的项目结构就是这样：    </p>
<pre><code>/pages/index<span class="hljs-selector-class">.vue</span> => /index<span class="hljs-selector-class">.html</span>    
/pages/about<span class="hljs-selector-class">.vue</span> => /about<span class="hljs-selector-class">.html</span>    
/pages/contact<span class="hljs-selector-class">.vue</span> => /contact.html</code></pre><p>说到生成页面，我们用api动态获取的文章内容要怎么在开发模式下渲染，又要怎么才能生成静态页面呢？</p>
<p>首先，我想要一个文章列表页，然后点击文章链接进入文章详情页，那么就需要一个/pages/blogs文件夹，然后添加index.vue和_slug.vue两个文件    </p>
<pre><code><span class="hljs-meta-keyword">/pages/</span>blogs/index.vue
<span class="hljs-meta-keyword">/pages/</span>blogs/_slug.vue</code></pre><p>index.vue是文章列表页，渲染方式是用Axios获取文章列表之后填充页面，而_slug.vue则是动态路由页面，会根据路由的参数<code>slug</code>来获取文章内容来渲染页面。</p>
<p>然而下划线开头的动态路由页面在生成静态页面的时候会被Nuxt忽略，除非你在nuxt.config.js里面指明要生成的动态路由路径，Nuxt才会根据路径一一生成。</p>
<p>假设我们的博客文章最终的静态网站访问路径是<code>/blogs/2019~~~</code>，同时我们还想要动态生成文章标签<code>/blogs/tag/aaa</code>，那么<code>nuxt.config.js</code>里面可以这样配置需要生成的页面所在的路径    </p>
<pre><code class="language-javascript">  generate: {
    <span class="hljs-attr">routes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">let</span> blogs = axios.get(<span class="hljs-string">'http://127.0.0.1:4000'</span>)
      .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> {<span class="hljs-comment">// res.data is array</span>
        <span class="hljs-keyword">return</span> res.data.blogs.map(<span class="hljs-function">(<span class="hljs-params">blog</span>) =></span> {
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">route</span>: <span class="hljs-string">'/blogs/'</span> + blog.slug,
            <span class="hljs-attr">payload</span>: blog
          }
        })
      })
      <span class="hljs-keyword">let</span> tags = axios.get(<span class="hljs-string">'http://127.0.0.1:4000?tag=all_tags'</span>)
      .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> {<span class="hljs-comment">// res.data is object</span>
        <span class="hljs-keyword">let</span> tags = <span class="hljs-built_in">Object</span>.keys(res.data.tags);
        <span class="hljs-keyword">return</span> tags.map(<span class="hljs-function">(<span class="hljs-params">tag</span>) =></span> {
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">route</span>: <span class="hljs-string">'/blogs/tag/'</span> + tag,
            <span class="hljs-attr">payload</span>: tag
          };
        });
      })
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([blogs, tags]).then(<span class="hljs-function"><span class="hljs-params">values</span> =></span> {
        <span class="hljs-keyword">return</span> [...values[<span class="hljs-number">0</span>], ...values[<span class="hljs-number">1</span>]]
      })
    }
  }</code></pre>
<p>注意里面的<code>payload</code>，虽然不知道为什么要用这个，但是用了确实能加快生成的速度。</p>
<h2 id="收获">收获</h2>
<p>前前后后花了两个多星期，我的博客终于有了新面貌，然而在这个过程中最惊喜的还是Youtube，想找什么样的教学视频都有。</p>
<p>而且它自动生成的字幕非常有用，各个国家千奇百怪的口音竟然都能识别出来，即使不是100%匹配，也能让我这个非英语母语的人跟上视频博主的思路。</p>
<p>在这里给Youtube点个赞！</p>
<h2 id="小插曲">小插曲</h2>
<p>本来页面导航栏和各种链接应该要使用<code>&lt;nuxt-link/></code>标签的，这样就可以用Nuxt的路由机制，加快访问速度。</p>
<p>但是它有一个问题是，在最终生成的静态网站上使用路由访问的时候，页面仍然会去请求127.0.0.1:4000上的内容，可是这时候api已经关闭了，请求失败之后页面就会来个“Network error”，可是如果使用URL去访问，又是可以加载出内容的。</p>
<p>所以我不得不忍痛割爱，把所有<code>&lt;nuxt-link/></code>的链接都换成了普通的<code>&lt;a>&lt;/a></code>标签的链接，这样静态网站就可以正常使用了。</p>
<h2 id="项目结构">项目结构</h2>
<pre><code>myblog
├─ <span class="hljs-selector-class">.nuxt</span>
├─ api    <span class="hljs-comment">//☆手动建立这个文件夹☆</span>
│   ├─ blogs    <span class="hljs-comment">//需要api解析的Markdown文件夹</span>
│   │   ├─ <span class="hljs-number">2019</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span>-set-up-static-blog-using-nuxt<span class="hljs-selector-class">.md</span>
│   │   ├─ <span class="hljs-number">2017</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span>-hao123-issue<span class="hljs-selector-class">.md</span>
│   │   └─ ...
│   └─ index<span class="hljs-selector-class">.js</span> <span class="hljs-comment">//api的入口，一个 node index.js 就跑起来了</span>
│               <span class="hljs-comment">//默认路径http://127.0.0.1:4000</span>
├─ components
│   ├─ Carousel<span class="hljs-selector-class">.vue</span>
│   ├─ Footer<span class="hljs-selector-class">.vue</span>
│   └─ Navigation<span class="hljs-selector-class">.vue</span>
├─ dist        <span class="hljs-comment">//☆最后生成的静态文件都在这里☆</span>
├─ layouts
│   ├─ default<span class="hljs-selector-class">.vue</span> <span class="hljs-comment">//Navigation + Nuxt(主要内容) + Footer</span>
│   └─ error<span class="hljs-selector-class">.vue</span> <span class="hljs-comment">//虽然按要求弄了error页面，可是找不到页面时还是</span>
│                <span class="hljs-comment">//跳去服务器(github)的404页，求大神指点</span>
├─ pages
│   ├─ blogs
│   │   ├─ tag
│   │   │   ├─ _tag<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">//动态渲染标签下的文章列表</span>
│   │   │   │            <span class="hljs-comment">// => /blogs/tag/aaa.html</span>
│   │   │   └─ index<span class="hljs-selector-class">.vue</span> <span class="hljs-comment">//文章标签页 => /blogs/tag.html</span>
│   │   ├─ _slug<span class="hljs-selector-class">.vue</span> <span class="hljs-comment">//动态渲染文章页面 </span>
│   │   │            <span class="hljs-comment">// => /blogs/2019~~.html</span>
│   │   └─ index<span class="hljs-selector-class">.vue</span> <span class="hljs-comment">//文章列表页 => /blogs.html</span>
│   ├─ about<span class="hljs-selector-class">.vue</span>
│   └─ index<span class="hljs-selector-class">.vue</span>     <span class="hljs-comment">//网站入口 => /index.html</span>
├─ static
│   ├─ <span class="hljs-selector-tag">img</span>
│   │   └─ home  <span class="hljs-comment">//首页用图 </span>
│   │       ├─ pic1<span class="hljs-selector-class">.jpg</span> <span class="hljs-comment">// => /img/home/bird1.jpg</span>
│   │       └─ pic2<span class="hljs-selector-class">.jpg</span> <span class="hljs-comment">// => /img/home/bird2.jpg</span>
│   ├─ favicon<span class="hljs-selector-class">.ico</span>  <span class="hljs-comment">//网站图标 => /favicon.ico</span>
│   └─ styles<span class="hljs-selector-class">.css</span>   <span class="hljs-comment">//公用css => /styles.css</span>
│
├─ myConfig<span class="hljs-selector-class">.js</span> <span class="hljs-comment">//一些自定义设置，用export default导出</span>
│              <span class="hljs-comment">//☆自己建立的，方便项目使用☆</span>
│              <span class="hljs-comment">//可以导入到vue文件中使用</span>
│
├─ nuxt<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span> <span class="hljs-comment">//nuxt网站整体设置，用module.exports导出</span>
│                 <span class="hljs-comment">//☆网站baseURL等设置全都在这里☆</span>
│                 <span class="hljs-comment">//无法被导入到vue文件中使用</span>
├─ ...   <span class="hljs-comment">//其他文件没动过</span></code></pre><h2 id="搭建网站的要点">搭建网站的要点</h2>
<ol>
<li><p>先安装<code>front-matter</code>的npm包，这个是用来解析Markdown文件前几行的meta data的。<br>然后在/api/文件夹内打开一个终端，用命令<code>node index.js</code>启动api，解析/api/blogs/文件夹内的Markdown文件，返回一个JSON，这个api在开发调试和生成静态页面过程中都需要保持开启状态。<br>index.js代码如下      </p>
<pre><code> var express = require("express");
 var fs = require("fs");
 var fm = require(<span class="hljs-string">'front-matter'</span>);
 var app = express();

 var singleBlog = <span class="hljs-keyword">function</span>(fullPath, slug, isContentRequired) {
     var blog = {};
     var content = fm(fs.readFileSync(fullPath, "utf8"));
     blog = content.attributes;
     blog.slug = slug;
     <span class="hljs-keyword">if</span> (isContentRequired) {
         blog.content = content.body;
     }
     <span class="hljs-keyword">return</span> blog;
 }

 app.<span class="hljs-keyword">get</span>("/", <span class="hljs-keyword">function</span>(req, res) {
     // allow <span class="hljs-keyword">cross</span> orign <span class="hljs-keyword">access</span>
     res.<span class="hljs-keyword">header</span>(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
     var <span class="hljs-type">path</span> = __dirname + <span class="hljs-string">'\\blogs'</span>;
     var files = fs.readdirSync(<span class="hljs-type">path</span>);

     var <span class="hljs-type">json</span> = {};// result <span class="hljs-keyword">to</span> be returned

     var qSlug = req.query.slug || "";
     var qImg = req.query.img || "";
     var qTag = req.query.tag || "";
     <span class="hljs-keyword">if</span> (qSlug) {// <span class="hljs-keyword">with</span> blog slug query
         <span class="hljs-type">json</span> = singleBlog(<span class="hljs-type">path</span>+"\\"+qSlug+".md", qSlug, <span class="hljs-keyword">true</span>);
     } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qImg) {// <span class="hljs-keyword">with</span> img query
         <span class="hljs-keyword">if</span> (qImg == "home") {
             <span class="hljs-type">json</span>.imgs = [];
             let imgs = fs.readdirSync("..\\static\\img\\home");
             imgs.<span class="hljs-keyword">forEach</span>((img, <span class="hljs-keyword">index</span>)=>{
                 <span class="hljs-type">json</span>.imgs[<span class="hljs-keyword">index</span>] = "./img/home/" + img;
             });
         }
     } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qTag) {// <span class="hljs-keyword">with</span> tag query
         <span class="hljs-keyword">if</span> (qTag == "all_tags") {// <span class="hljs-keyword">returns</span> list <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> available tags
             <span class="hljs-type">json</span>.tags = {};
             <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
                 let blogPost = singleBlog(<span class="hljs-type">path</span>+"\\"+files[i], files[i].replace(".md", ""));
                 let tags = blogPost.tags || [<span class="hljs-string">'none'</span>];
                 let entry = {
                     title: blogPost.title,
                     slug: blogPost.slug
                 };
                 <span class="hljs-keyword">for</span> (let j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {
                     <span class="hljs-keyword">if</span> (<span class="hljs-type">json</span>.tags[tags[j]]) {
                         <span class="hljs-type">json</span>.tags[tags[j]].push(entry);
                     } <span class="hljs-keyword">else</span> {
                         <span class="hljs-type">json</span>.tags[tags[j]] = [];
                         <span class="hljs-type">json</span>.tags[tags[j]].push(entry);
                     }
                 }
             }
         } <span class="hljs-keyword">else</span> {// <span class="hljs-keyword">returns</span> blog list <span class="hljs-keyword">of</span> specific tag
             <span class="hljs-type">json</span>.blogs = [];
             <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
                 let blogPost = singleBlog(<span class="hljs-type">path</span>+"\\"+files[i], files[i].replace(".md", ""));
                 let tags = blogPost.tags || [<span class="hljs-string">'none'</span>];
                 let entry = {
                     title: blogPost.title,
                     slug: blogPost.slug
                 };
                 <span class="hljs-keyword">for</span> (let j = <span class="hljs-number">0</span>; j &lt; tags.length; j++) {
                     <span class="hljs-keyword">if</span> (tags[j] == qTag) {
                         <span class="hljs-type">json</span>.blogs.push(blogPost);
                     }
                 }
             }
         }
     } <span class="hljs-keyword">else</span> {//<span class="hljs-keyword">without</span> requirement, <span class="hljs-keyword">returns</span> list <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> blogs
         <span class="hljs-type">json</span>.blogs = [];
         <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; files.length; i++) {
             let blogPost = singleBlog(<span class="hljs-type">path</span>+"\\"+files[i], files[i].replace(".md", ""));
             <span class="hljs-type">json</span>.blogs.push(blogPost);
         }
     }
     res.send(<span class="hljs-type">json</span>);
 });

 app.<span class="hljs-keyword">listen</span>(<span class="hljs-number">4000</span>, () => {
     console.log("express server running at http://127.0.0.1:4000")
 });</code></pre><p>这个api可以：    </p>
<ol>
<li>请求时不加参数则返回所有文章列表</li>
<li>请求时加参数slug则返回特定文章内容</li>
<li>请求时加参数tag则返回特定tag下的文章列表</li>
</ol>
</li>
<li><p>在components组件文件夹内建立Navigation.vue和Footer.vue，在layouts布局文件夹的default.vue里组合起来</p>
</li>
<li><p>根目录下建立index.vue、about.vue和blogs文件夹，里面新建index.vue和_slug.vue两个文件。以下划线开头的vue文件会被Nuxt解析为动态路由，当用户在浏览器里访问符合路径规则的页面地址时就会渲染出相应的页面。</p>
</li>
<li><p>在<code>/blogs/index.vue</code>里面需要用Axios获取api返回的所有文章列表</p>
<pre><code class="language-javascript"> <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
 <span class="hljs-keyword">import</span> myConfig <span class="hljs-keyword">from</span> <span class="hljs-string">"../../myConfig"</span>;
 <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
   asyncData({ params }) {
     <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'http://127.0.0.1:4000?slug='</span>+params.slug).then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {
       <span class="hljs-keyword">let</span> blog = res.data;
       <span class="hljs-keyword">let</span> space = [];
       <span class="hljs-keyword">let</span> tags = blog.tags || [<span class="hljs-string">'none'</span>];
       <span class="hljs-keyword">return</span> {
         <span class="hljs-attr">blog</span>: blog,
         <span class="hljs-attr">tags</span>: tags,
         <span class="hljs-attr">date</span>: params.slug.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>),
         <span class="hljs-attr">baseURL</span>: myConfig.baseURL
       };
     })
   }
   ...
 }</code></pre>
</li>
<li><p>在<code>/blogs/_slug.vue</code>里面需要用Axios获取api返回的单篇文章内容    </p>
<pre><code class="language-javascript">asyncData({ <span class="hljs-keyword">params</span> }) {
 <span class="hljs-keyword">return</span> axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">'http://127.0.0.1:4000?slug='</span>+<span class="hljs-keyword">params</span>.slug).then(res => {
   <span class="hljs-keyword">let</span> blog = res.data;
   <span class="hljs-keyword">let</span> space = [];
   <span class="hljs-keyword">let</span> tags = blog.tags || [<span class="hljs-string">'none'</span>];
   <span class="hljs-keyword">return</span> {
     blog: blog,
     tags: tags,
     date: <span class="hljs-keyword">params</span>.slug.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>),
     baseURL: myConfig.baseURL
   };
 })
}</code></pre>
</li>
</ol>
<p>然后记得要装<code>marked</code>和<code>highlight.js</code>，把api返回来的Markdown格式文本渲染成最后想要的HTML内容。    </p>
<pre><code>    <span class="hljs-keyword">import</span> marked <span class="hljs-keyword">from</span> <span class="hljs-string">'marked'</span>;
    <span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highlight.js'</span>);
    computed: {
        <span class="hljs-attr">compiledMarkdown</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> rendererMD = <span class="hljs-keyword">new</span> marked.Renderer();
            <span class="hljs-keyword">var</span> html = marked(<span class="hljs-keyword">this</span>.blog.content, {
                <span class="hljs-attr">renderer</span>: rendererMD,
                <span class="hljs-attr">gfm</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">tables</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">breaks</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">pedantic</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">sanitize</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">smartLists</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">smartypants</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code</span>) </span>{
                    <span class="hljs-keyword">return</span> hljs.highlightAuto(code).value
                }
            });
            <span class="hljs-comment">/*把文章内链接使用新标签页打开*/</span>
            html = html.replace(<span class="hljs-regexp">/href\=\"http/g</span>, <span class="hljs-string">"target=\"_blank\" href=\"http"</span>);
            <span class="hljs-comment">/*页内跳转一定要加上前面的路径*/</span>
            html = html.replace(<span class="hljs-regexp">/href\=\"\#/g</span>, <span class="hljs-string">"href=\"blogs/"</span> + <span class="hljs-keyword">this</span>.blog.slug + <span class="hljs-string">"#"</span>);
            <span class="hljs-comment">/*
            **以下是处理Youtube视频和略缩图的代码
            **我不想用iframe在本页打开视频，所以给略缩图加个效果，然后新标签页打开
            */</span>
            <span class="hljs-keyword">var</span> youtubeArr = html.match(<span class="hljs-regexp">/&lt;img src=\"https:\/\/i\.ytimg\.com\/vi\/[^(&lt;|>)]+default\.jpg\" alt=\"youtube-img\">/g</span>);
            <span class="hljs-keyword">if</span> (youtubeArr) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; youtubeArr.length; i++) {
                html = html.replace(youtubeArr[i], <span class="hljs-string">"&lt;span class=\"youtube-img\">"</span> + youtubeArr[i] + <span class="hljs-string">"&lt;/span>"</span>);
              }
            }
            <span class="hljs-keyword">return</span> html;
        }
    },</code></pre><p>重要的地方就是这些了，其他的想起来再补充。</p>
<p>以上~</p>
</div> <div id="disqus_thread"></div></div></main> <footer data-v-4bfe094d><p data-v-4bfe094d>Created by <strong data-v-4bfe094d>Jenny HOU</strong>.</p> <div class="statcounter" style="width:0;height:0" data-v-4bfe094d><a title="Web Analytics Made Easy - StatCounter" href="https://statcounter.com/" target="_blank" data-v-4bfe094d><img src="https://c.statcounter.com/11716132/0/63c1267e/0/" alt="Web Analytics Made Easy -
			StatCounter" class="statcounter" data-v-4bfe094d></a></div></footer></div></div></div><script>window.__NUXT__=function(t){return t[0]="涨知识",t[1]="Nuxt",{layout:"default",data:[{blog:{layout:"post",title:"如何使用Nuxt建立个人博客",description:"Node解析Markdown，建立API返回JSON，Nuxt+Axios获取文章内容并生成静态页面",tags:t,slug:"2019-05-05-set-up-static-blog-using-nuxt",content:'## Nuxt是什么？\r\n\r\n>Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染(SSR) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等优势。\r\n\r\n## 为什么要从Jekyll转成Nuxt？\r\n\r\n其实也没啥原因，就是想自己做个网站试试。\r\n\r\n之前用的Jekyll模板是别人做的，自己就算想做点个性化设置也无从下手。\r\n\r\n况且Jekyll是用Ruby写的，自从上次尝试安装Ruby失败之后，我就对Jekyll失望了。\r\n\r\n因为没能安装Ruby，我也从来没能在本机上预览我的博客，只能是部署到GitHub之后才能看到成果，所以就更加失望了。\r\n\r\n之前某大佬推荐说，可以试着用Nuxt做网站，因为Nuxt是基于Vue的框架，而我正好除了Vue之外啥也不会，所以应该适合我。\r\n\r\n于是就开始整了。\r\n\r\n## 准备工作和建立博客的探索\r\n\r\n首先得装vue-cli，有vue-cli之后起一个Nuxt示例项目，然后放着不动。\r\n\r\n在实际开始做事之前，我先看了以下的Youtube教学视频，每一个都翻来覆去看了两三遍\r\n\r\nYoutube视频教程：**使用Nuxt(框架)和storyblok(基于api提供内容的CMS)建立个人博客**\r\n\r\n[![youtube-img](https://i.ytimg.com/vi/Dc_5BpIB4X4/default.jpg)](https://www.youtube.com/watch?v=Dc_5BpIB4X4 \'The Front-End | Nuxt.js & Storyblok - Building a Complete Blog\')\r\n[![youtube-img](https://i.ytimg.com/vi/UIh4P5rNjac/default.jpg)](https://www.youtube.com/watch?v=UIh4P5rNjac \'Adding Storyblok CMS | Nuxt.js & Storyblok - Building a Complete Blog\')\r\n[![youtube-img](https://i.ytimg.com/vi/Yq6Ddu_QAiY/default.jpg)](https://www.youtube.com/watch?v=Yq6Ddu_QAiY \'Storyblok Live Preview! | Nuxt.js & Storyblok - Building a Complete Blog\')\r\n[![youtube-img](https://i.ytimg.com/vi/JHCKab2oS4s/default.jpg)](https://www.youtube.com/watch?v=JHCKab2oS4s \'Final Touches & Deploying the Blog | Nuxt.js & Storyblok - Building a Complete Blog\')\r\n\r\n视频的主要内容是使用Nuxt建立博客首页（文章列表页）、附属页面，建立页面导航路由，然后在博客详情页用Axios加载api传来的文章内容，最后生成静态网站。\r\n\r\n除了storyblok之外还有contentful等提供内容管理的网站，但是我不想依赖外部内容资源，也不想注册这些网站，于是就只是照着视频先起了个项目，写了些components和layout，然后建立了几个page。\r\n\r\n其实也就三个：index.vue, about.vue, blogs.vue。\r\n\r\n然后发现了另外一个Youtube视频教程：**使用Nuxt生成静态网站**    \r\n[![youtube-img](https://i.ytimg.com/vi/pI2qHPI0ZpU/default.jpg)](https://www.youtube.com/watch?v=pI2qHPI0ZpU \'Nuxt.js - Static Site Generator\')\r\n\r\n这一个视频的主要内容是不使用外部资源，博客文章页也用.vue的文件书写，最后生成静态网站。\r\n\r\n但是我不想专门给每一篇文章都开一个.vue的文件，这样没法在其他地方复用，也不能从别的项目导入Markdown文章。\r\n\r\n于是我在google上搜索如何让Nuxt使用Markdown文件作为资源生成静态博客，然后找到一个Nuxt官方团队的github issue    \r\n[Using markdown as articles?](https://github.com/nuxt/nuxt.js/issues/396)\r\n\r\n中间有一楼说自己在Nuxt项目之外开了个api，以作返回Markdown文章内容之用，而楼内有个Nuxt官方成员回复说，可能考虑在Nuxt项目内添加一个叫作“serverMiddleware”的东西，这样就不用去另外开api来返回文章内容了。\r\n\r\n这个issue是2017年的，我希望这么久的时间足够他们添加这个feature，于是又去搜“Nuxt serverMiddleware”，果然有惊喜。\r\n\r\n然后我又看了这个Youtube视频：**手把手教你在Nuxt项目中使用serverMiddleware**    \r\n[![youtube-img](https://i.ytimg.com/vi/j-3RwvWZoaU/default.jpg)](https://www.youtube.com/watch?v=j-3RwvWZoaU \'Why You Should Learn Server Middleware with Nuxt.js! A step-by-step tutorial!\')\r\n\r\n这个视频教了一下serverMiddleware的api路径配置，以及api的服务端代码怎么写。\r\n\r\n这个api主要是作为一个express的Node服务器，可以指定它解析特定文件夹，并返回JSON，这样就完成了一个简易的api。由于Nuxt集成了express，我们可以直接配置serverMiddleware，马上就能使用。\r\n\r\n于是我在项目内新增一个api的文件夹，里面摆放我旧博客里的Markdown文章，然后用api去做解析。\r\n\r\n但是这样也有一个问题，api的服务端代码还没完全写好的时候，需要经常中断进程，修改完代码之后再重新开启。可是npm run dev一次就要好几分钟，而我可能就只是改了几个变量名，这样实在是太低效了。\r\n\r\n而且在npm run generate生成静态网站的时候，如果这个api没有处于运行状态，是无法返回文章内容的。可是如果这边开一个终端运行开发模式，那边又开一个终端生成静态页面的话，两边都会报很多错，一行一行的红色警告吓死人。\r\n\r\n于是我只好放弃serverMiddleware，让这个api单独去运行。\r\n\r\nNuxt项目在开发模式下是在localhost:3000上运行，而这个api则是在127.0.0.1:4000上，在项目运行开发模式之前先把api启动，调试完了关闭开发模式，然后生成静态页面，完了之后再把api关掉。\r\n\r\n这样就成了。\r\n\r\n## 生成静态页面\r\n\r\n说到生成静态页面，在默认情况下，/pages/index.vue会成为根目录下的首页，而用户在```/pages```文件夹下新建了多少个.vue文件，到时候就会在根目录下生成多少个文件夹，文件夹名就是原本的.vue文件名，而文件夹里则是一个index.html。\r\n\r\n差不多像这样：    \r\n```\r\n/pages/index.vue => /index.html  \r\n/pages/about.vue => /about/index.html\r\n/pages/contact.vue => /contact/index.html    \r\n```\r\n\r\n但是这样会多出好多文件夹，最终生成的网站结构总感觉不太明晰。这个时候就需要到/nuxt.config.js里面做总配置，把subFolders设置为false即可。    \r\n```javascript\r\n\tmodule.exports = {\r\n\t\t...\r\n\t\tgenerate: {\r\n\t\t\t...\r\n\t\t\tsubFolders: false\r\n\t\t\t...\r\n\t\t}\r\n\t\t...\r\n\t}\r\n```\r\n\r\n这样配置后生成的项目结构就是这样：    \r\n```\r\n/pages/index.vue => /index.html    \r\n/pages/about.vue => /about.html    \r\n/pages/contact.vue => /contact.html\r\n```\r\n\r\n说到生成页面，我们用api动态获取的文章内容要怎么在开发模式下渲染，又要怎么才能生成静态页面呢？\r\n\r\n首先，我想要一个文章列表页，然后点击文章链接进入文章详情页，那么就需要一个/pages/blogs文件夹，然后添加index.vue和_slug.vue两个文件    \r\n```\r\n/pages/blogs/index.vue\r\n/pages/blogs/_slug.vue\r\n```\r\n\r\nindex.vue是文章列表页，渲染方式是用Axios获取文章列表之后填充页面，而_slug.vue则是动态路由页面，会根据路由的参数```slug```来获取文章内容来渲染页面。\r\n\r\n然而下划线开头的动态路由页面在生成静态页面的时候会被Nuxt忽略，除非你在nuxt.config.js里面指明要生成的动态路由路径，Nuxt才会根据路径一一生成。\r\n\r\n假设我们的博客文章最终的静态网站访问路径是```/blogs/2019~~~```，同时我们还想要动态生成文章标签```/blogs/tag/aaa```，那么```nuxt.config.js```里面可以这样配置需要生成的页面所在的路径    \r\n```javascript\r\n  generate: {\r\n    routes: function () {\r\n      let blogs = axios.get(\'http://127.0.0.1:4000\')\r\n      .then((res) => {// res.data is array\r\n        return res.data.blogs.map((blog) => {\r\n          return {\r\n            route: \'/blogs/\' + blog.slug,\r\n            payload: blog\r\n          }\r\n        })\r\n      })\r\n      let tags = axios.get(\'http://127.0.0.1:4000?tag=all_tags\')\r\n      .then((res) => {// res.data is object\r\n        let tags = Object.keys(res.data.tags);\r\n        return tags.map((tag) => {\r\n          return {\r\n            route: \'/blogs/tag/\' + tag,\r\n            payload: tag\r\n          };\r\n        });\r\n      })\r\n      return Promise.all([blogs, tags]).then(values => {\r\n        return [...values[0], ...values[1]]\r\n      })\r\n    }\r\n  }\r\n```\r\n\r\n注意里面的```payload```，虽然不知道为什么要用这个，但是用了确实能加快生成的速度。\r\n\r\n## 收获\r\n\r\n前前后后花了两个多星期，我的博客终于有了新面貌，然而在这个过程中最惊喜的还是Youtube，想找什么样的教学视频都有。\r\n\r\n而且它自动生成的字幕非常有用，各个国家千奇百怪的口音竟然都能识别出来，即使不是100%匹配，也能让我这个非英语母语的人跟上视频博主的思路。\r\n\r\n在这里给Youtube点个赞！\r\n\r\n## 小插曲\r\n\r\n本来页面导航栏和各种链接应该要使用```<nuxt-link/>```标签的，这样就可以用Nuxt的路由机制，加快访问速度。\r\n\r\n但是它有一个问题是，在最终生成的静态网站上使用路由访问的时候，页面仍然会去请求127.0.0.1:4000上的内容，可是这时候api已经关闭了，请求失败之后页面就会来个“Network error”，可是如果使用URL去访问，又是可以加载出内容的。\r\n\r\n所以我不得不忍痛割爱，把所有```<nuxt-link/>```的链接都换成了普通的```<a></a>```标签的链接，这样静态网站就可以正常使用了。\r\n\r\n## 项目结构\r\n\r\n```\r\nmyblog\r\n├─ .nuxt\r\n├─ api    //☆手动建立这个文件夹☆\r\n│   ├─ blogs    //需要api解析的Markdown文件夹\r\n│   │   ├─ 2019-05-05-set-up-static-blog-using-nuxt.md\r\n│   │   ├─ 2017-05-28-hao123-issue.md\r\n│   │   └─ ...\r\n│   └─ index.js //api的入口，一个 node index.js 就跑起来了\r\n│               //默认路径http://127.0.0.1:4000\r\n├─ components\r\n│   ├─ Carousel.vue\r\n│   ├─ Footer.vue\r\n│   └─ Navigation.vue\r\n├─ dist        //☆最后生成的静态文件都在这里☆\r\n├─ layouts\r\n│   ├─ default.vue //Navigation + Nuxt(主要内容) + Footer\r\n│   └─ error.vue //虽然按要求弄了error页面，可是找不到页面时还是\r\n│                //跳去服务器(github)的404页，求大神指点\r\n├─ pages\r\n│   ├─ blogs\r\n│   │   ├─ tag\r\n│   │   │   ├─ _tag.vue  //动态渲染标签下的文章列表\r\n│   │   │   │            // => /blogs/tag/aaa.html\r\n│   │   │   └─ index.vue //文章标签页 => /blogs/tag.html\r\n│   │   ├─ _slug.vue //动态渲染文章页面 \r\n│   │   │            // => /blogs/2019~~.html\r\n│   │   └─ index.vue //文章列表页 => /blogs.html\r\n│   ├─ about.vue\r\n│   └─ index.vue     //网站入口 => /index.html\r\n├─ static\r\n│   ├─ img\r\n│   │   └─ home  //首页用图 \r\n│   │       ├─ pic1.jpg // => /img/home/bird1.jpg\r\n│   │       └─ pic2.jpg // => /img/home/bird2.jpg\r\n│   ├─ favicon.ico  //网站图标 => /favicon.ico\r\n│   └─ styles.css   //公用css => /styles.css\r\n│\r\n├─ myConfig.js //一些自定义设置，用export default导出\r\n│              //☆自己建立的，方便项目使用☆\r\n│              //可以导入到vue文件中使用\r\n│\r\n├─ nuxt.config.js //nuxt网站整体设置，用module.exports导出\r\n│                 //☆网站baseURL等设置全都在这里☆\r\n│                 //无法被导入到vue文件中使用\r\n├─ ...   //其他文件没动过\r\n```\r\n\r\n## 搭建网站的要点\r\n\r\n1. 先安装```front-matter```的npm包，这个是用来解析Markdown文件前几行的meta data的。   \r\n然后在/api/文件夹内打开一个终端，用命令```node index.js```启动api，解析/api/blogs/文件夹内的Markdown文件，返回一个JSON，这个api在开发调试和生成静态页面过程中都需要保持开启状态。     \r\nindex.js代码如下      \r\n```\r\n\tvar express = require("express");\r\n\tvar fs = require("fs");\r\n\tvar fm = require(\'front-matter\');\r\n\tvar app = express();\r\n\r\n\tvar singleBlog = function(fullPath, slug, isContentRequired) {\r\n\t\tvar blog = {};\r\n\t\tvar content = fm(fs.readFileSync(fullPath, "utf8"));\r\n\t\tblog = content.attributes;\r\n\t\tblog.slug = slug;\r\n\t\tif (isContentRequired) {\r\n\t\t\tblog.content = content.body;\r\n\t\t}\r\n\t\treturn blog;\r\n\t}\r\n\r\n\tapp.get("/", function(req, res) {\r\n\t\t// allow cross orign access\r\n\t\tres.header(\'Access-Control-Allow-Origin\', \'*\');\r\n\t\tvar path = __dirname + \'\\\\blogs\';\r\n\t\tvar files = fs.readdirSync(path);\r\n\r\n\t\tvar json = {};// result to be returned\r\n\r\n\t\tvar qSlug = req.query.slug || "";\r\n\t\tvar qImg = req.query.img || "";\r\n\t\tvar qTag = req.query.tag || "";\r\n\t\tif (qSlug) {// with blog slug query\r\n\t\t\tjson = singleBlog(path+"\\\\"+qSlug+".md", qSlug, true);\r\n\t\t} else if (qImg) {// with img query\r\n\t\t\tif (qImg == "home") {\r\n\t\t\t\tjson.imgs = [];\r\n\t\t\t\tlet imgs = fs.readdirSync("..\\\\static\\\\img\\\\home");\r\n\t\t\t\timgs.forEach((img, index)=>{\r\n\t\t\t\t\tjson.imgs[index] = "./img/home/" + img;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (qTag) {// with tag query\r\n\t\t\tif (qTag == "all_tags") {// returns list of all available tags\r\n\t\t\t\tjson.tags = {};\r\n\t\t\t\tfor (let i = 0; i < files.length; i++) {\r\n\t\t\t\t\tlet blogPost = singleBlog(path+"\\\\"+files[i], files[i].replace(".md", ""));\r\n\t\t\t\t\tlet tags = blogPost.tags || [\'none\'];\r\n\t\t\t\t\tlet entry = {\r\n\t\t\t\t\t\ttitle: blogPost.title,\r\n\t\t\t\t\t\tslug: blogPost.slug\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfor (let j = 0; j < tags.length; j++) {\r\n\t\t\t\t\t\tif (json.tags[tags[j]]) {\r\n\t\t\t\t\t\t\tjson.tags[tags[j]].push(entry);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tjson.tags[tags[j]] = [];\r\n\t\t\t\t\t\t\tjson.tags[tags[j]].push(entry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {// returns blog list of specific tag\r\n\t\t\t\tjson.blogs = [];\r\n\t\t\t\tfor (let i = 0; i < files.length; i++) {\r\n\t\t\t\t\tlet blogPost = singleBlog(path+"\\\\"+files[i], files[i].replace(".md", ""));\r\n\t\t\t\t\tlet tags = blogPost.tags || [\'none\'];\r\n\t\t\t\t\tlet entry = {\r\n\t\t\t\t\t\ttitle: blogPost.title,\r\n\t\t\t\t\t\tslug: blogPost.slug\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfor (let j = 0; j < tags.length; j++) {\r\n\t\t\t\t\t\tif (tags[j] == qTag) {\r\n\t\t\t\t\t\t\tjson.blogs.push(blogPost);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {//without requirement, returns list of all blogs\r\n\t\t\tjson.blogs = [];\r\n\t\t\tfor (let i = 0; i < files.length; i++) {\r\n\t\t\t\tlet blogPost = singleBlog(path+"\\\\"+files[i], files[i].replace(".md", ""));\r\n\t\t\t\tjson.blogs.push(blogPost);\r\n\t\t\t}\r\n\t\t}\r\n\t\tres.send(json);\r\n\t});\r\n\r\n\tapp.listen(4000, () => {\r\n\t\tconsole.log("express server running at http://127.0.0.1:4000")\r\n\t});\r\n``` \r\n这个api可以：    \r\n\t1. 请求时不加参数则返回所有文章列表\r\n\t2. 请求时加参数slug则返回特定文章内容\r\n\t3. 请求时加参数tag则返回特定tag下的文章列表\r\n\r\n2. 在components组件文件夹内建立Navigation.vue和Footer.vue，在layouts布局文件夹的default.vue里组合起来\r\n\r\n3. 根目录下建立index.vue、about.vue和blogs文件夹，里面新建index.vue和_slug.vue两个文件。以下划线开头的vue文件会被Nuxt解析为动态路由，当用户在浏览器里访问符合路径规则的页面地址时就会渲染出相应的页面。\r\n\r\n4. 在```/blogs/index.vue```里面需要用Axios获取api返回的所有文章列表\r\n```javascript\r\n\timport axios from \'axios\'\r\n\timport myConfig from "../../myConfig";\r\n\texport default {\r\n\t  asyncData({ params }) {\r\n\t    return axios.get(\'http://127.0.0.1:4000?slug=\'+params.slug).then(res => {\r\n\t      let blog = res.data;\r\n\t      let space = [];\r\n\t      let tags = blog.tags || [\'none\'];\r\n\t      return {\r\n\t        blog: blog,\r\n\t        tags: tags,\r\n\t        date: params.slug.substring(0,10),\r\n\t        baseURL: myConfig.baseURL\r\n\t      };\r\n\t    })\r\n\t  }\r\n\t  ...\r\n\t}\r\n```\r\n\r\n5. 在```/blogs/_slug.vue```里面需要用Axios获取api返回的单篇文章内容    \r\n```javascript\r\n  asyncData({ params }) {\r\n    return axios.get(\'http://127.0.0.1:4000?slug=\'+params.slug).then(res => {\r\n      let blog = res.data;\r\n      let space = [];\r\n      let tags = blog.tags || [\'none\'];\r\n      return {\r\n        blog: blog,\r\n        tags: tags,\r\n        date: params.slug.substring(0,10),\r\n        baseURL: myConfig.baseURL\r\n      };\r\n    })\r\n  }\r\n```\r\n\r\n然后记得要装```marked```和```highlight.js```，把api返回来的Markdown格式文本渲染成最后想要的HTML内容。    \r\n```\r\n\timport marked from \'marked\';\r\n\tvar hljs = require(\'highlight.js\');\r\n\tcomputed: {\r\n\t\tcompiledMarkdown: function () {\r\n\t\t\tvar rendererMD = new marked.Renderer();\r\n\t\t\tvar html = marked(this.blog.content, {\r\n\t\t\t\trenderer: rendererMD,\r\n\t\t\t\tgfm: true,\r\n\t\t\t\ttables: true,\r\n\t\t\t\tbreaks: false,\r\n\t\t\t\tpedantic: false,\r\n\t\t\t\tsanitize: false,\r\n\t\t\t\tsmartLists: true,\r\n\t\t\t\tsmartypants: false,\r\n\t\t\t\thighlight: function (code) {\r\n\t\t\t\t\treturn hljs.highlightAuto(code).value\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t/*把文章内链接使用新标签页打开*/\r\n\t\t\thtml = html.replace(/href\\=\\"http/g, "target=\\"_blank\\" href=\\"http");\r\n\t\t\t/*页内跳转一定要加上前面的路径*/\r\n\t\t\thtml = html.replace(/href\\=\\"\\#/g, "href=\\"blogs/" + this.blog.slug + "#");\r\n\t\t\t/*\r\n\t\t\t**以下是处理Youtube视频和略缩图的代码\r\n\t\t\t**我不想用iframe在本页打开视频，所以给略缩图加个效果，然后新标签页打开\r\n\t\t\t*/\r\n\t\t\tvar youtubeArr = html.match(/<img src=\\"https:\\/\\/i\\.ytimg\\.com\\/vi\\/[^(<|>)]+default\\.jpg\\" alt=\\"youtube-img\\">/g);\r\n\t\t\tif (youtubeArr) {\r\n\t\t\t\t    for (let i = 0; i < youtubeArr.length; i++) {\r\n\t\t\t    html = html.replace(youtubeArr[i], "<span class=\\"youtube-img\\">" + youtubeArr[i] + "</span>");\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\treturn html;\r\n\t\t}\r\n\t},\r\n```\r\n重要的地方就是这些了，其他的想起来再补充。\r\n\r\n以上~'},tags:t,date:"2019-05-05",baseURL:"/"}],error:null,serverRendered:!0}}(Array(2))</script><script src="/_nuxt/61bcbbd34eb29ae7ae0d.js" defer></script><script src="/_nuxt/33ef648db803cfae2c04.js" defer></script><script src="/_nuxt/ec0b83a3fb195aad8df5.js" defer></script><script src="/_nuxt/fb1304f7c79d4074ba22.js" defer></script>
  </body>
</html>
