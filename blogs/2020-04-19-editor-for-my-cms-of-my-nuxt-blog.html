<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">写了一个CMS用的UI界面 | Jenny的小站</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="我更新博客的流程是先编辑Markdown文件，再由Nuxt从API里面获取出来，然后生成静态页面，这个流程已经很完整了。但是我一直想为这个API写个编辑器的界面UI，让这个API能像个真正的CMS一样来使用，今天花了一整天的时间，终于写好了。"><meta data-n-head="true" data-hid="keyword" name="keyword" content="涨知识, JavaScript, Node, jQuery"><link data-n-head="true" rel="icon" type="image/x-icon" href="/img/favicon.ico"><link data-n-head="true" rel="stylesheet" href="/css/font-gugi.css"><link data-n-head="true" rel="stylesheet" href="/css/font-poppins.css"><link data-n-head="true" rel="stylesheet" href="/css/style.css?2020-04-12"><link data-n-head="true" rel="stylesheet" href="/font-awesome/css/font-awesome.min.css"><link data-n-head="true" rel="stylesheet" href="/css/github-markdown.min.css"><link data-n-head="true" rel="stylesheet" href="/css/highlight.js.css"><link data-n-head="true" rel="stylesheet" href="https://hzn-website.000webhostapp.com/disqus/dist/iDisqus.min.css"><script data-n-head="true" src="/js/statcounter.js"></script><base href="/"><link rel="preload" href="/_nuxt/ccd755dabfbe46e96ed1.js" as="script"><link rel="preload" href="/_nuxt/03fcc68d4bc19df4b6dc.js" as="script"><link rel="preload" href="/_nuxt/a738d17800e56e7f0932.js" as="script"><link rel="preload" href="/_nuxt/30e82ba3e703d4fc9637.js" as="script"><style data-vue-ssr-id="17cfdfa9:0 498b36b5:0 1bd5369a:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#3b8070;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}.markdown-body{margin-bottom:50px}.markdown-body img{max-height:100px}a[id]{position:relative;top:-40px;display:block}a#comment-link{top:0}.blog-desc{margin:10px;padding:10px;color:#666;background-color:rgba(0,0,0,.025)}.youtube-img{position:relative;display:inline-block}.youtube-img:before{width:40%;height:40%;border-radius:25%;background:rgba(0,0,0,.7);transition:background .2s}.youtube-img:after,.youtube-img:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.youtube-img:after{width:0;height:0;border-top:10px solid transparent;border-left:20px solid #fff;border-bottom:10px solid transparent}.youtube-img:hover:before{background:red}#disqus_thread{margin-top:20px}.prev-next{margin:20px auto;display:block}.prev-next:after{display:table;content:" ";clear:both}.prev-next a{display:inline}.next,.prev{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin:20px auto;width:100%;color:grey;border:1px solid grey;cursor:pointer}.prev{width:48%;text-align:left;float:left}.next{width:48%;text-align:right;float:right}.next:hover,.prev:hover{color:#000;border-color:#000}.prev p{padding-left:16px}.next p,.prev p{margin:0;padding-top:16px;padding-bottom:16px}.next p{padding-right:16px}#comment{margin-top:40px}.blog-gallery{margin:20px auto;display:flex;justify-content:center;flex-wrap:wrap;overflow:hidden}.blog-gallery-unit{margin:40px 10px 0;width:46%;border:1px solid silver;border-radius:5px}.blog-gallery-unit:first-child,.blog-gallery-unit:nth-child(2){margin-top:20px}.blog-gallery-unit:hover{border-color:#000}.blog-gallery-inner{padding:21px 10px 10px;height:100%}.blog-gallery-inner h4{margin-top:0;max-height:42px;overflow:hidden}.blog-gallery-desc{line-height:21px;max-height:64px;display:block;overflow:hidden}.blog-gallery-tag{margin:1px;padding:0 8px;color:#fff;font-size:12px;font-family:Microsoft Yahei;line-height:20px;border-radius:999px;background:grey;display:inline-block}@media (max-width:425px){.blog-gallery-unit{width:100%}}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="container"><nav><div class="nav-wrap"><header><a href="/" class="no-decor-link"><p class="nav-home">Jenny's blog</p></a></header> <div class="nav-btn"><div class="bar"></div> <div class="bar"></div> <div class="bar"></div> <div class="bar"></div></div> <div class="nav-mask"></div> <div class="body-mask"></div> <ul class="nav-ul"><a href="/" target="_self" class="nav-link"><li>首页<!----><!----></li></a><a href="/resume" target="_self" class="nav-link"><li>简历<!----><!----></li></a><a href="/blogs" target="_self" class="nav-link nuxt-link-active"><li>博客<!----><!----></li></a><a href="https://wj.qq.com/s2/3731207/f0cd/" target="_blank" class="nav-link"><li>联系我<span> </span><i class="fa fa-external-link"></i></li></a></ul></div></nav> <main><div><section class="main-content"><h1 class="align-center">写了一个CMS用的UI界面</h1> <p class="blog-date align-center"><span class="fa fa-calendar"> 2020-04-19</span></p> <p class="blog-tags align-center"><a href="/blogs/tag/涨知识"><span class="blog-tag">涨知识</span></a><a href="/blogs/tag/JavaScript"><span class="blog-tag">JavaScript</span></a><a href="/blogs/tag/Node"><span class="blog-tag">Node</span></a><a href="/blogs/tag/jQuery"><span class="blog-tag">jQuery</span></a></p> <div class="blog-desc">我更新博客的流程是先编辑Markdown文件，再由Nuxt从API里面获取出来，然后生成静态页面，这个流程已经很完整了。但是我一直想为这个API写个编辑器的界面UI，让这个API能像个真正的CMS一样来使用，今天花了一整天的时间，终于写好了。</div> <article class="markdown-body"><p></p><h3> </h3><ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#CMS_1">一个真正的CMS</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_15">需要掌握的知识</a></li><ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_17">后端</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_24">前端</a></li></ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_40">实际编程的结果</a></li><ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_42">后端写法</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_106">前端写法</a></li></ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_151">大概是这么个效果</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_163">心得体会</a></li></ul><p></p>
<h1><a id="CMS_1"></a>一个真正的CMS</h1>
<p>去年开始学习使用 <code>Nuxt</code> 的时候，看了很多关于 <code>Headless CMS</code>，也就是所谓 <code>无界面内容管理系统</code> 的很多网站介绍以及相关使用方法，自己也尝试使用了一下，但是没有坚持到底，还是想不依赖这些外部服务来构建自己的网站。</p>
<p>后来我自己写出了可以用作 <code>CMS</code> 的 <code>API</code>，可以参见 <a href="/blogs/2019-05-05-set-up-static-blog-using-nuxt">这里</a>。</p>
<p>这个 <code>API</code> 让我可以只需更新 <code>Markdown</code> 文章，再使用 <code>Nuxt</code> 的生成静态页面的功能就可以更新我的网站。通常我是用 <code>Sublime Text</code> 这个编辑器来编写代码的，它可以在左边显示工程文件，切换起来也挺方便的。</p>
<blockquote>
<p>可是人类就是喜欢自找麻烦。</p>
<p>by 我</p>
</blockquote>
<p>我想要一个有界面的 <code>CMS</code>，能新建，能修改，能读取，能保存，删除就不用了。感觉上像是操作数据库，但是实际上我们只是操作一个文件夹里的 <code>Markdown</code> 文件而已。</p>
<h1><a id="_15"></a>需要掌握的知识</h1>
<h2><a id="_17"></a>后端</h2>
<p>由于我原本的 <code>API</code> 是用 <code>Node</code> 的 <code>express</code> 服务器写的，所以还是想在此基础上继续精进，那么就需要掌握 <code>Node</code> 服务器的一些用法，比如：</p>
<ol>
<li>让 <code>API</code> 读取静态页面，使浏览器能显示 <code>CMS</code> 的 UI 界面。</li>
<li>让 <code>API</code> 能接受浏览器（客户端）传回来的数据，并保存到本地。</li>
</ol>
<h2><a id="_24"></a>前端</h2>
<p>由于我之前还有一个在 <a href="https://www.codepen.io">CodePen</a> 上的 <a href="https://codepen.io/c53hzn/full/YzzRzxR">Markdown Viewer</a> 的项目，所以想要直接拿来改改就上马。</p>
<p>不过这个预览器是用 <code>Marked.js</code> 做渲染的，而我的 <code>API</code> 里面是用 <code>Markdown-it</code> 来做渲染的，为了统一写法，得把渲染的方式改成 <code>Markdown-it</code>。</p>
<p>而且这个项目是用 <code>jQuery</code> 写的，我最终决定继续用 <code>jQuery</code> 来写前端的页面。</p>
<p>那么我们就需要解决以下的问题：</p>
<ol>
<li>读取 <code>API</code> 传来的文章列表并渲染到文章列表区</li>
<li>读取 <code>API</code> 传来的文章内容并渲染文章的标题、标签、描述、关联文章、正文到各个输入框，以及最重要的 <code>Markdown</code> 编辑器</li>
<li>每当 <code>Markdown</code> 编辑器有更新时，预览区也要跟着更新，预览区还应该有代码高亮和一般样式渲染</li>
<li>点击 <code>Save</code> 的时候，页面要检查各个输入框是否都有内容，没有则 <code>alert</code> 让填写内容，有的话再检查文章是否已存在，存在则问要不要更新，不存在则问要不要创建</li>
<li>当确认要更新或创建的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交内容到服务器，并获取提交结果，反映到浏览器</li>
</ol>
<h1><a id="_40"></a>实际编程的结果</h1>
<h2><a id="_42"></a>后端写法</h2>
<p>首先在 <code>API</code> 的入口文件 <code>index.js</code> 里面改一下配置，这样就可以控制返回的文章正文是 <code>Markdown</code> 还是经过处理的 <code>HTML</code> 内容。</p>
<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath, slug, isContentRequired, isMD</span>) </span>{
  <span class="hljs-keyword">var</span> blog = {};
  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));
  blog = content.attributes;
  blog.slug = slug;
  <span class="hljs-keyword">if</span> (isContentRequired && !isMD) {
    blog.content = md.render(<span class="hljs-string">'@[toc]( )\n'</span> + content.body);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isContentRequired && isMD) {
    blog.content = content.body;
  }
  <span class="hljs-keyword">return</span> blog;
}

app.get(<span class="hljs-string">"/blogs"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">var</span> qIsMD = (req.query.ismd == <span class="hljs-string">"true"</span>) || <span class="hljs-literal">false</span>;
  <span class="hljs-comment">//...</span>
});
</code></pre>
<p>我在 <code>API</code> 所在的文件夹新建了 <code>index.html</code>，以作为 UI 界面的入口，而要让 <code>API</code> 可以访问这个静态页面，就要像下面这样写</p>
<pre><code class="language-JavaScript"><span class="hljs-comment">//return blog content editor page</span>
app.use(express.static(__dirname));
app.get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// allow cross orign access</span>
  res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
  res.sendFile(__dirname+<span class="hljs-string">"\\index.html"</span>);
});
<span class="hljs-comment">/*
//...some other codes
*/</span>
<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>
app.listen(<span class="hljs-number">4000</span>, () => {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)
});
</code></pre>
<p>那么这个 <code>CMS</code> 的入口链接就是 <code>http://127.0.0.1:4000/</code> 了。</p>
<p>之后就是接受浏览器传回来的数据并保存到本地</p>
<pre><code class="language-JavaScript"><span class="hljs-comment">// Parse URL-encoded bodies (as sent by HTML forms)</span>
app.use(express.urlencoded({ <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));
<span class="hljs-comment">// Parse JSON bodies (as sent by API clients)</span>
app.use(express.json());
<span class="hljs-comment">// Access the parse results as request.body</span>
app.post(<span class="hljs-string">'/savepost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
  <span class="hljs-keyword">var</span> obj = req.body;
  <span class="hljs-keyword">var</span> fileName = __dirname+<span class="hljs-string">"\\blogs\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;
  fs.writeFileSync(fileName, obj.str);
  <span class="hljs-comment">//Client will get status of failure w/o this</span>
  <span class="hljs-comment">//even if data is saved to server successfully</span>
  res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});
});
</code></pre>
<h2><a id="_106"></a>前端写法</h2>
<p>具体代码其实没什么好说的，文章列表的 <code>API</code> 是 <code>/blogs</code>，而保存文章的 <code>API</code> 则是 <code>/savepost</code>，前者可以用 <code>jQuery</code> 的 <code>getJSON</code> 方法来获取数据，后者可以用 <code>jQuery</code> 的 <code>post</code> 方法来提交数据。</p>
<p>但是这里可能要注意一下 <code>Node</code> 模块在引入浏览器时的用法。</p>
<p>原本作为 <code>Node</code> 模块使用的时候，先</p>
<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it'</span>);
<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it-toc'</span>);
</code></pre>
<p>然后</p>
<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> md = markdownIt({
  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,
  <span class="hljs-attr">xhtmlOut</span>:     <span class="hljs-literal">false</span>,
  <span class="hljs-attr">breaks</span>:       <span class="hljs-literal">false</span>,
  <span class="hljs-attr">langPrefix</span>:   <span class="hljs-string">'language-'</span>,
  <span class="hljs-attr">linkify</span>:      <span class="hljs-literal">false</span>,
  <span class="hljs-attr">typographer</span>:  <span class="hljs-literal">false</span>,
  <span class="hljs-attr">quotes</span>: <span class="hljs-string">'“”‘’'</span>,
  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{
    <span class="hljs-keyword">if</span> (lang && hljs.getLanguage(lang)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;
      } <span class="hljs-keyword">catch</span> (__) {}
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  }
});
md.use(markdownItToc);
</code></pre>
<p>就可以用来渲染 <code>Markdown</code> 了。</p>
<p>但是在浏览器里用的时候总是报错，这个对象找不到，那个对象也找不到，反正我就是没有对象就是了。</p>
<p>后来才发现，作者在写成浏览器能用的版本时，暴露出来的变量名的大小写跟我引用的不一样。</p>
<p>我挨个 <code>js</code> 文件打开，发现<code>markdown-it</code> 在浏览器里的变量名是 <code>markdownit</code>，而用来生成锚点链接的 <code>markdown-it-toc</code> 的变量名是 <code>markdownitTOC</code>，于是我把自己的脚本里面的变量名改成跟原变量名一致，然后就有对象可以用了。</p>
<p>这个问题本来不应该是问题的，实在是让人懊恼。</p>
<h1><a id="_151"></a>大概是这么个效果</h1>
<p>需要访问 <code>API</code> 的时候，可以 <code>cd</code> 进入该 <code>API</code> 的文件夹，然后</p>
<pre><code>node index.js
</code></pre>
<p>再在浏览器里打开 <code>http://127.0.0.1:4000/</code> 这个页面，就能看到文章列表，可以修改旧文章，或者新增文章了。参考以下截图</p>
<p><img src="/img/blogs/2020-04-19/001.png" alt="preview"></p>
<h1><a id="_163"></a>心得体会</h1>
<p>今天终于把我心心念念想了一年的东西做出来了，而且只花了一天的时间，真的很开心。</p>
<p>希望学到的东西能够派上用场吧。</p>
</article> <div class="prev-next"><a href="/blogs/2020-04-13-script-for-photoshop-bulk-resize-and-watermark-en" class="no-decor-link"><div class="prev"><p>上一篇</p></div></a> <!----></div> <div><h3 style="text-align:center"><span style="border-bottom:2px solid #000">相关文章</span></h3> <div class="blog-gallery"><div class="blog-gallery-unit"><a href="/blogs/2019-05-05-set-up-static-blog-using-nuxt" title="重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>如何使用Nuxt建立个人博客</h4> <p class="blog-date"><span class="fa fa-calendar">
               2019-05-05
            </span></p> <p class="align-left"><span class="blog-gallery-desc">重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                涨知识
              </span><span class="blog-gallery-tag">
                JavaScript
              </span><span class="blog-gallery-tag">
                Nuxt
              </span><span class="blog-gallery-tag">
                静态博客
              </span></span></p></div></a></div><div class="blog-gallery-unit"><a href="/blogs/2020-01-31-a-little-summary-of-my-life-in-2019" title="我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。
" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>2019年的小总结</h4> <p class="blog-date"><span class="fa fa-calendar">
               2020-01-31
            </span></p> <p class="align-left"><span class="blog-gallery-desc">我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。
</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                小日常
              </span><span class="blog-gallery-tag">
                剧评
              </span><span class="blog-gallery-tag">
                追星
              </span><span class="blog-gallery-tag">
                涨知识
              </span><span class="blog-gallery-tag">
                JavaScript
              </span></span></p></div></a></div></div></div> <div id="comment"></div></section></div></main> <footer><p>Created with Nuxt.js <br>
    	Made by  
    	<a href="https://github.com/c53hzn" target="_blank" class="no-decor-link"><strong>Jenny HOU</strong> <i class="fa fa-github font-20"></i></a></p> <div class="go-top go-top-hidden"><div class="arrow"></div> <div class="stick"></div></div></footer></div></div></div><script>window.__NUXT__=function(s,a,n,e,l,o,p,c){return o[0]=n,o[1]=e,o[2]="Node",o[3]="jQuery",{layout:"page",data:[{blog:{layout:a,title:"写了一个CMS用的UI界面",description:"我更新博客的流程是先编辑Markdown文件，再由Nuxt从API里面获取出来，然后生成静态页面，这个流程已经很完整了。但是我一直想为这个API写个编辑器的界面UI，让这个API能像个真正的CMS一样来使用，今天花了一整天的时间，终于写好了。",tags:o,comments:!0,related_blog:[l,p],slug:"2020-04-19-editor-for-my-cms-of-my-nuxt-blog",content:'<p><h3> </h3><ul><li><a href="#CMS_1">一个真正的CMS</a></li><li><a href="#_15">需要掌握的知识</a></li><ul><li><a href="#_17">后端</a></li><li><a href="#_24">前端</a></li></ul><li><a href="#_40">实际编程的结果</a></li><ul><li><a href="#_42">后端写法</a></li><li><a href="#_106">前端写法</a></li></ul><li><a href="#_151">大概是这么个效果</a></li><li><a href="#_163">心得体会</a></li></ul></p>\n<h1><a id="CMS_1"></a>一个真正的CMS</h1>\n<p>去年开始学习使用 <code>Nuxt</code> 的时候，看了很多关于 <code>Headless CMS</code>，也就是所谓 <code>无界面内容管理系统</code> 的很多网站介绍以及相关使用方法，自己也尝试使用了一下，但是没有坚持到底，还是想不依赖这些外部服务来构建自己的网站。</p>\n<p>后来我自己写出了可以用作 <code>CMS</code> 的 <code>API</code>，可以参见 <a href="/blogs/2019-05-05-set-up-static-blog-using-nuxt">这里</a>。</p>\n<p>这个 <code>API</code> 让我可以只需更新 <code>Markdown</code> 文章，再使用 <code>Nuxt</code> 的生成静态页面的功能就可以更新我的网站。通常我是用 <code>Sublime Text</code> 这个编辑器来编写代码的，它可以在左边显示工程文件，切换起来也挺方便的。</p>\n<blockquote>\n<p>可是人类就是喜欢自找麻烦。</p>\n<p>by 我</p>\n</blockquote>\n<p>我想要一个有界面的 <code>CMS</code>，能新建，能修改，能读取，能保存，删除就不用了。感觉上像是操作数据库，但是实际上我们只是操作一个文件夹里的 <code>Markdown</code> 文件而已。</p>\n<h1><a id="_15"></a>需要掌握的知识</h1>\n<h2><a id="_17"></a>后端</h2>\n<p>由于我原本的 <code>API</code> 是用 <code>Node</code> 的 <code>express</code> 服务器写的，所以还是想在此基础上继续精进，那么就需要掌握 <code>Node</code> 服务器的一些用法，比如：</p>\n<ol>\n<li>让 <code>API</code> 读取静态页面，使浏览器能显示 <code>CMS</code> 的 UI 界面。</li>\n<li>让 <code>API</code> 能接受浏览器（客户端）传回来的数据，并保存到本地。</li>\n</ol>\n<h2><a id="_24"></a>前端</h2>\n<p>由于我之前还有一个在 <a href="https://www.codepen.io">CodePen</a> 上的 <a href="https://codepen.io/c53hzn/full/YzzRzxR">Markdown Viewer</a> 的项目，所以想要直接拿来改改就上马。</p>\n<p>不过这个预览器是用 <code>Marked.js</code> 做渲染的，而我的 <code>API</code> 里面是用 <code>Markdown-it</code> 来做渲染的，为了统一写法，得把渲染的方式改成 <code>Markdown-it</code>。</p>\n<p>而且这个项目是用 <code>jQuery</code> 写的，我最终决定继续用 <code>jQuery</code> 来写前端的页面。</p>\n<p>那么我们就需要解决以下的问题：</p>\n<ol>\n<li>读取 <code>API</code> 传来的文章列表并渲染到文章列表区</li>\n<li>读取 <code>API</code> 传来的文章内容并渲染文章的标题、标签、描述、关联文章、正文到各个输入框，以及最重要的 <code>Markdown</code> 编辑器</li>\n<li>每当 <code>Markdown</code> 编辑器有更新时，预览区也要跟着更新，预览区还应该有代码高亮和一般样式渲染</li>\n<li>点击 <code>Save</code> 的时候，页面要检查各个输入框是否都有内容，没有则 <code>alert</code> 让填写内容，有的话再检查文章是否已存在，存在则问要不要更新，不存在则问要不要创建</li>\n<li>当确认要更新或创建的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交内容到服务器，并获取提交结果，反映到浏览器</li>\n</ol>\n<h1><a id="_40"></a>实际编程的结果</h1>\n<h2><a id="_42"></a>后端写法</h2>\n<p>首先在 <code>API</code> 的入口文件 <code>index.js</code> 里面改一下配置，这样就可以控制返回的文章正文是 <code>Markdown</code> 还是经过处理的 <code>HTML</code> 内容。</p>\n<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath, slug, isContentRequired, isMD</span>) </span>{\n  <span class="hljs-keyword">var</span> blog = {};\n  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));\n  blog = content.attributes;\n  blog.slug = slug;\n  <span class="hljs-keyword">if</span> (isContentRequired &amp;&amp; !isMD) {\n    blog.content = md.render(<span class="hljs-string">\'@[toc]( )\\n\'</span> + content.body);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isContentRequired &amp;&amp; isMD) {\n    blog.content = content.body;\n  }\n  <span class="hljs-keyword">return</span> blog;\n}\n\napp.get(<span class="hljs-string">"/blogs"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n  <span class="hljs-comment">//...</span>\n  <span class="hljs-keyword">var</span> qIsMD = (req.query.ismd == <span class="hljs-string">"true"</span>) || <span class="hljs-literal">false</span>;\n  <span class="hljs-comment">//...</span>\n});\n</code></pre>\n<p>我在 <code>API</code> 所在的文件夹新建了 <code>index.html</code>，以作为 UI 界面的入口，而要让 <code>API</code> 可以访问这个静态页面，就要像下面这样写</p>\n<pre><code class="language-JavaScript"><span class="hljs-comment">//return blog content editor page</span>\napp.use(express.static(__dirname));\napp.get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n  <span class="hljs-comment">// allow cross orign access</span>\n  res.header(<span class="hljs-string">\'Access-Control-Allow-Origin\'</span>, <span class="hljs-string">\'*\'</span>);\n  res.sendFile(__dirname+<span class="hljs-string">"\\\\index.html"</span>);\n});\n<span class="hljs-comment">/*\n//...some other codes\n*/</span>\n<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>\napp.listen(<span class="hljs-number">4000</span>, () =&gt; {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)\n});\n</code></pre>\n<p>那么这个 <code>CMS</code> 的入口链接就是 <code>http://127.0.0.1:4000/</code> 了。</p>\n<p>之后就是接受浏览器传回来的数据并保存到本地</p>\n<pre><code class="language-JavaScript"><span class="hljs-comment">// Parse URL-encoded bodies (as sent by HTML forms)</span>\napp.use(express.urlencoded({ <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));\n<span class="hljs-comment">// Parse JSON bodies (as sent by API clients)</span>\napp.use(express.json());\n<span class="hljs-comment">// Access the parse results as request.body</span>\napp.post(<span class="hljs-string">\'/savepost\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{\n  <span class="hljs-keyword">var</span> obj = req.body;\n  <span class="hljs-keyword">var</span> fileName = __dirname+<span class="hljs-string">"\\\\blogs\\\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;\n  fs.writeFileSync(fileName, obj.str);\n  <span class="hljs-comment">//Client will get status of failure w/o this</span>\n  <span class="hljs-comment">//even if data is saved to server successfully</span>\n  res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});\n});\n</code></pre>\n<h2><a id="_106"></a>前端写法</h2>\n<p>具体代码其实没什么好说的，文章列表的 <code>API</code> 是 <code>/blogs</code>，而保存文章的 <code>API</code> 则是 <code>/savepost</code>，前者可以用 <code>jQuery</code> 的 <code>getJSON</code> 方法来获取数据，后者可以用 <code>jQuery</code> 的 <code>post</code> 方法来提交数据。</p>\n<p>但是这里可能要注意一下 <code>Node</code> 模块在引入浏览器时的用法。</p>\n<p>原本作为 <code>Node</code> 模块使用的时候，先</p>\n<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it\'</span>);\n<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it-toc\'</span>);\n</code></pre>\n<p>然后</p>\n<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> md = markdownIt({\n  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">xhtmlOut</span>:     <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">breaks</span>:       <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">langPrefix</span>:   <span class="hljs-string">\'language-\'</span>,\n  <span class="hljs-attr">linkify</span>:      <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">typographer</span>:  <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">quotes</span>: <span class="hljs-string">\'“”‘’\'</span>,\n  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{\n    <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;\n      } <span class="hljs-keyword">catch</span> (__) {}\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>;\n  }\n});\nmd.use(markdownItToc);\n</code></pre>\n<p>就可以用来渲染 <code>Markdown</code> 了。</p>\n<p>但是在浏览器里用的时候总是报错，这个对象找不到，那个对象也找不到，反正我就是没有对象就是了。</p>\n<p>后来才发现，作者在写成浏览器能用的版本时，暴露出来的变量名的大小写跟我引用的不一样。</p>\n<p>我挨个 <code>js</code> 文件打开，发现<code>markdown-it</code> 在浏览器里的变量名是 <code>markdownit</code>，而用来生成锚点链接的 <code>markdown-it-toc</code> 的变量名是 <code>markdownitTOC</code>，于是我把自己的脚本里面的变量名改成跟原变量名一致，然后就有对象可以用了。</p>\n<p>这个问题本来不应该是问题的，实在是让人懊恼。</p>\n<h1><a id="_151"></a>大概是这么个效果</h1>\n<p>需要访问 <code>API</code> 的时候，可以 <code>cd</code> 进入该 <code>API</code> 的文件夹，然后</p>\n<pre><code>node index.js\n</code></pre>\n<p>再在浏览器里打开 <code>http://127.0.0.1:4000/</code> 这个页面，就能看到文章列表，可以修改旧文章，或者新增文章了。参考以下截图</p>\n<p><img src="/img/blogs/2020-04-19/001.png" alt="preview"></p>\n<h1><a id="_163"></a>心得体会</h1>\n<p>今天终于把我心心念念想了一年的东西做出来了，而且只花了一天的时间，真的很开心。</p>\n<p>希望学到的东西能够派上用场吧。</p>\n',prev:"2020-04-13-script-for-photoshop-bulk-resize-and-watermark-en"},tags:o,date:"2020-04-19",relatedBlog:[{layout:a,title:"如何使用Nuxt建立个人博客",description:"重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。",tags:[n,e,"Nuxt","静态博客"],comments:!0,related_blog:["2018-03-28-set-up-static-blog",c],slug:l,prev:"2018-12-21-Korean-drama-memories-of-the-alhambra-n-feel-good-to-die",next:c,date:"2019-05-05"},{layout:a,title:"2019年的小总结",description:"我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。\n",related_blog:["2019-08-17-tv-drama-the-birth-of-the-drama-king",l,"2020-02-13-tv-drama-die-now"],tags:["小日常","剧评","追星",n,e],author:"author1",comments:!0,slug:p,prev:"2019-12-28-why-vlookup-cannot-return-value",next:"2020-02-01-memories-about-plagues",date:"2020-01-31"}],baseURL:"/",ui_str:{to_prev:"上一篇",to_next:"下一篇",related_posts:"相关文章"}}],error:null,serverRendered:!0}}(0,"post","涨知识","JavaScript","2019-05-05-set-up-static-blog-using-nuxt",Array(4),"2020-01-31-a-little-summary-of-my-life-in-2019","2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs")</script><script src="/_nuxt/ccd755dabfbe46e96ed1.js" defer></script><script src="/_nuxt/30e82ba3e703d4fc9637.js" defer></script><script src="/_nuxt/03fcc68d4bc19df4b6dc.js" defer></script><script src="/_nuxt/a738d17800e56e7f0932.js" defer></script>
  </body>
</html>
