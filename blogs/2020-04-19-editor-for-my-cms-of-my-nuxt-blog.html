<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>给Nuxt使用的基于API的CMS——还有管理后台呢 | Jenny的小站</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="去年给我的Nuxt博客网站建了一个解析Markdown文件的API当做CMS，这次给API写了个管理界面，开启API就能运行，兼具Headless CMS和Flat File CMS的特征，开心~"><meta data-n-head="ssr" data-hid="keyword" name="keyword" content="我的项目, JavaScript, Node.js, jQuery"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/img/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="/css/font-gugi.css"><link data-n-head="ssr" rel="stylesheet" href="/css/font-poppins.css"><link data-n-head="ssr" rel="stylesheet" href="/css/style.css?2020-04-12"><link data-n-head="ssr" rel="stylesheet" href="/font-awesome/css/font-awesome.min.css"><link data-n-head="ssr" rel="stylesheet" href="/css/github-markdown.min.css"><link data-n-head="ssr" rel="stylesheet" href="/css/hljs.dark.min.css"><link data-n-head="ssr" rel="stylesheet" href="https://hzn-website.000webhostapp.com/disqus/dist/iDisqus.min.css"><script data-n-head="ssr" src="/js/statcounter.js"></script><base href="/"><link rel="preload" href="/_nuxt/2d31f6c0bf5b6a854bae.js" as="script"><link rel="preload" href="/_nuxt/275bef93b4559841d52d.js" as="script"><link rel="preload" href="/_nuxt/c69520ae9fda1118c222.js" as="script"><link rel="preload" href="/_nuxt/adb15844b8ba2f434984.js" as="script"><style data-vue-ssr-id="3191d5ad:0 53a11731:0 f28bdea2:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#3b8070;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}.markdown-body{margin-bottom:50px}.markdown-body img{max-height:100px}a[id]{position:relative;top:-40px;display:block}a#comment-link{top:0}.blog-desc{margin:10px;padding:10px;color:#666;background-color:rgba(0,0,0,.025)}.youtube-img{position:relative;display:inline-block}.youtube-img:before{width:40%;height:40%;border-radius:25%;background:rgba(0,0,0,.7);transition:background .2s}.youtube-img:after,.youtube-img:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.youtube-img:after{width:0;height:0;border-top:10px solid transparent;border-left:20px solid #fff;border-bottom:10px solid transparent}.youtube-img:hover:before{background:red}#disqus_thread{margin-top:20px}.prev-next{margin:20px auto;display:block}.prev-next:after{display:table;content:" ";clear:both}.prev-next a{display:inline}.next,.prev{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin:20px auto;width:100%;color:grey;border:1px solid grey;cursor:pointer}.prev{width:48%;text-align:left;float:left}.next{width:48%;text-align:right;float:right}.next:hover,.prev:hover{color:#000;border-color:#000}.prev p{padding-left:16px}.next p,.prev p{margin:0;padding-top:16px;padding-bottom:16px}.next p{padding-right:16px}#comment{margin-top:40px}.blog-gallery{margin:20px auto;display:flex;justify-content:center;flex-wrap:wrap;overflow:hidden}.blog-gallery-unit{margin:40px 10px 0;width:46%;border:1px solid silver;border-radius:5px}.blog-gallery-unit:first-child,.blog-gallery-unit:nth-child(2){margin-top:20px}.blog-gallery-unit:hover{border-color:#000}.blog-gallery-inner{padding:21px 10px 10px;height:100%}.blog-gallery-inner h4{margin-top:0;max-height:42px;overflow:hidden}.blog-gallery-desc{line-height:21px;max-height:64px;display:block;overflow:hidden}.blog-gallery-tag{margin:1px;padding:0 8px;color:#fff;font-size:12px;font-family:Microsoft Yahei;line-height:20px;border-radius:999px;background:grey;display:inline-block}@media (max-width:425px){.blog-gallery-unit{width:100%}}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="container"><nav><div class="nav-wrap"><header><a href="/" class="no-decor-link"><p class="nav-home">Jenny's blog</p></a></header> <div class="nav-btn"><div class="bar"></div> <div class="bar"></div> <div class="bar"></div> <div class="bar"></div></div> <div class="nav-mask"></div> <div class="body-mask"></div> <ul class="nav-ul"><a href="/" target="_self" class="nav-link"><li>首页<!----><!----></li></a><a href="/resume" target="_self" class="nav-link"><li>简历<!----><!----></li></a><a href="/blogs" target="_self" class="nav-link nuxt-link-active"><li>博客<!----><!----></li></a><a href="https://wj.qq.com/s2/3731207/f0cd/" target="_blank" class="nav-link"><li>联系我<span> </span><i class="fa fa-external-link"></i></li></a></ul></div></nav> <main><div><section class="main-content"><h1 class="align-center">给Nuxt使用的基于API的CMS——还有管理后台呢</h1> <p class="blog-date align-center"><span class="fa fa-calendar"> 2020-04-19</span></p> <p class="blog-tags align-center"><a href="/blogs/tag/我的项目"><span class="blog-tag">我的项目</span></a><a href="/blogs/tag/JavaScript"><span class="blog-tag">JavaScript</span></a><a href="/blogs/tag/Node.js"><span class="blog-tag">Node.js</span></a><a href="/blogs/tag/jQuery"><span class="blog-tag">jQuery</span></a></p> <div class="blog-desc">去年给我的Nuxt博客网站建了一个解析Markdown文件的API当做CMS，这次给API写了个管理界面，开启API就能运行，兼具Headless CMS和Flat File CMS的特征，开心~</div> <article class="markdown-body"><p></p><h3> </h3><ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#CMS_1">一个真正的CMS</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_19">后端需要实现的效果</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_28">前端需要实现的效果</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_49">后端的实际写法</a></li><ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#API__Markdown_51">API 被调用时直接返回未处理的 Markdown</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_API__76">给 API 添加管理后台入口</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_106">保存文件和删除文件</a></li></ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_141">前端的实际写法</a></li><ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_API__Markdown_143">调用 API 和渲染 Markdown</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_Markdown__149">渲染 Markdown 时的注意事项</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_193">添加页内平滑滚动效果</a></li></ul><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_221">大概是这么个效果</a></li><li><a href="blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog#_233">心得体会</a></li></ul><p></p>
<h1><a id="CMS_1"></a>一个真正的CMS</h1>
<p>去年开始学习使用 <code>Nuxt</code> 的时候，看了很多关于 <code>Headless CMS</code> 的介绍，按我的理解，就是 <code>不带前端页面设计的内容管理系统</code> ，研究了一下这类的项目以及相关使用方法，自己也尝试使用了一下，但是没有坚持到底，还是想不依赖这些外部服务来构建自己的网站。不过评论系统和访客统计还是得用外部服务，因为静态网站服务器做不到这些。</p>
<p>后来我自己写出了可以用作 <code>CMS</code> 的 <code>API</code>，可以参见 <a href="/blogs/2019-05-05-set-up-static-blog-using-nuxt">这里</a>。</p>
<p>这个 <code>API</code> 让我可以只需更新 <code>Markdown</code> 文章，再使用 <code>Nuxt</code> 的生成静态页面的功能就可以更新我的网站。通常我是用 <code>Sublime Text</code> 这个编辑器来编写代码的，它可以在左边显示工程文件，切换起来也挺方便的。</p>
<blockquote>
<p>可是人类就是喜欢自找麻烦。</p>
<p>by 我</p>
</blockquote>
<p>我想要一个有界面的 <code>CMS</code>，能新建，能修改，能读取，能保存，能删除。但是我只要操作 <code>Markdown</code> 文件，而不要任何数据库。</p>
<p>我觉得我能做到。</p>
<p>写了个<a href="/blogs/2020-04-26-editor-for-my-cms-of-my-nuxt-blog-en">英文版</a>，大家随便看看就好。</p>
<h1><a id="_19"></a>后端需要实现的效果</h1>
<p>由于我原本的 <code>API</code> 是用 <code>Node</code> 的 <code>express</code> 写的，所以还是想在此基础上继续精进，那么就需要掌握 <code>Node</code> 服务器的一些用法，比如：</p>
<ol>
<li>让 <code>API</code> 读取静态 HTML 页面，使浏览器能显示 <code>CMS</code> 的 UI 界面。</li>
<li>开启 <code>API</code> 的时候自动打开浏览器访问入口，也就是前一项的 UI 界面。</li>
<li>让 <code>API</code> 能接受浏览器（客户端）传回来的数据，并保存到本地。</li>
<li>让 <code>API</code> 接受浏览器传回来的数据，然后删除相关文件。</li>
</ol>
<h1><a id="_28"></a>前端需要实现的效果</h1>
<p>我之前还有一个在 <a href="https://www.codepen.io">CodePen</a> 上的 <a href="https://codepen.io/c53hzn/full/YzzRzxR">Markdown Previewer</a> 的项目，半年来浏览量一只手就能数得清，就这么放着也挺可惜，不如拿来这里用一用。</p>
<p>CodePen 项目的渲染效果是用 <code>marked</code> 来实现的的，而我的 <code>API</code> 里面是用 <code>markdown-it</code> 来做渲染的，为了统一写法，得把渲染的方式改成 <code>Markdown-it</code>。</p>
<p>这个项目主体是用 <code>jQuery</code> 写的，我最终决定继续用 <code>jQuery</code> 来写前端的页面交互。</p>
<p>那么我们就需要解决以下的问题：</p>
<ol>
<li>读取 <code>API</code> 传来的文章列表并渲染到文章列表区</li>
<li>读取 <code>API</code> 传来的文章内容并渲染文章的标题、标签、描述、关联文章、正文到各个输入框，以及最重要的 <code>Markdown</code> 编辑器</li>
<li>每当 <code>Markdown</code> 编辑器有更新时，预览区也要跟着更新，预览区还应该有代码高亮和一般样式渲染</li>
<li>点击 <code>Save post</code> 的时候，页面要检查各个输入框是否都有内容，没有则 <code>alert</code> 让填写内容，有的话再检查文章是否已存在，存在则 <code>confirm</code> 要不要更新，不存在则 <code>confirm</code> 要不要创建。</li>
<li>点击 <code>Delete post</code> 的时候，页面要检查 <code>slug</code> 在文章列表里是否存在，不存在则 <code>alert</code> 说没东西可删，如果存在则要 <code>confirm</code> 是否真的删除。</li>
<li>键盘按下 <code>ctrl+enter</code> 触发保存，效果等同于点击 <code>Save post</code>。</li>
<li>当确认要更新或创建的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交内容到服务器，并获取提交结果，反映到浏览器</li>
<li>当确认要删除的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交要删除的 <code>slug</code> 到服务器，并获取删除结果，反映到浏览器。</li>
</ol>
<p>并且这些要在一个页面里完成。</p>
<h1><a id="_49"></a>后端的实际写法</h1>
<h2><a id="API__Markdown_51"></a>API 被调用时直接返回未处理的 Markdown</h2>
<p>首先在 <code>API</code> 的入口文件 <code>index.js</code> 里面改一下配置，这样就可以控制返回的文章正文是 <code>Markdown</code> 还是经过处理的 <code>HTML</code> 内容。</p>
<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath, slug, isContentRequired, isMD</span>) </span>{
  <span class="hljs-keyword">var</span> blog = {};
  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));
  blog = content.attributes;
  blog.slug = slug;
  <span class="hljs-keyword">if</span> (isContentRequired && !isMD) {
    blog.content = md.render(<span class="hljs-string">'@[toc]( )\n'</span> + content.body);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isContentRequired && isMD) {
    blog.content = content.body;
  }
  <span class="hljs-keyword">return</span> blog;
}

app.get(<span class="hljs-string">"/blogs"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">var</span> qIsMD = (req.query.ismd == <span class="hljs-string">"true"</span>) || <span class="hljs-literal">false</span>;
  <span class="hljs-comment">//...</span>
});
</code></pre>
<h2><a id="_API__76"></a>给 API 添加管理后台入口</h2>
<p>我在 <code>API</code> 所在的文件夹新建了 <code>index.html</code>，以作为 UI 界面的入口，而要让 <code>API</code> 可以访问这个静态页面，就要像下面这样写</p>
<pre><code class="language-JavaScript"><span class="hljs-comment">//return blog content editor page</span>
app.use(express.static(__dirname));
app.get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// allow cross orign access</span>
  res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>);
  res.sendFile(__dirname+<span class="hljs-string">"\\index.html"</span>);
});
<span class="hljs-comment">/*
//...some other codes
*/</span>
<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>
app.listen(<span class="hljs-number">4000</span>, () => {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)
});
</code></pre>
<p>那么这个 <code>CMS</code> 的入口链接就是 <code>http://127.0.0.1:4000/</code> 了。</p>
<p>为了能在开启 <code>API</code> 的时候自动打开浏览器并访问该地址，还需要使用 <code>open</code> 这个 <code>npm</code>，然后加一行打开浏览器的指令</p>
<pre><code class="language-JavaScript">open(<span class="hljs-string">"http:127.0.0.1:4000/"</span>,{<span class="hljs-attr">app</span>: <span class="hljs-string">"chrome.exe"</span>});
</code></pre>
<p>就能直接自动打开浏览器并访问 <code>CMS</code> 的管理界面了。这个界面总共也就一页，所以很好管理。</p>
<h2><a id="_106"></a>保存文件和删除文件</h2>
<p>之后就是接受浏览器传回来的数据并保存到本地，或者接收浏览器传回的删除指令，删除相关文件。</p>
<pre><code class="language-JavaScript"><span class="hljs-comment">// save post</span>
<span class="hljs-comment">// Parse URL-encoded bodies (as sent by HTML forms)</span>
app.use(express.urlencoded({ <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));
<span class="hljs-comment">// Parse JSON bodies (as sent by API clients)</span>
app.use(express.json());
<span class="hljs-comment">// Access the parse results as request.body</span>
app.post(<span class="hljs-string">'/savepost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
  <span class="hljs-keyword">var</span> obj = req.body;
  <span class="hljs-keyword">var</span> fileName = __dirname+<span class="hljs-string">"\\blogs\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;
  fs.writeFileSync(fileName, obj.str);
  <span class="hljs-comment">//Client will get status of failure w/o this</span>
  <span class="hljs-comment">//even if data is saved to server successfully</span>
  res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});
});
<span class="hljs-comment">// delete post</span>
app.post(<span class="hljs-string">'/deletepost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
  <span class="hljs-keyword">var</span> obj = req.body;
  <span class="hljs-keyword">var</span> fileName = __dirname+<span class="hljs-string">"\\blogs\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;
  <span class="hljs-keyword">try</span> {
    fs.unlinkSync(fileName);
    <span class="hljs-comment">//file removed</span>
  } <span class="hljs-keyword">catch</span>(err) {
    <span class="hljs-built_in">console</span>.error(err);
  }
  <span class="hljs-comment">//Client will get status of failure w/o this</span>
  <span class="hljs-comment">//even if data is saved to server successfully</span>
  res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});
});
</code></pre>
<h1><a id="_141"></a>前端的实际写法</h1>
<h2><a id="_API__Markdown_143"></a>调用 API 和渲染 Markdown</h2>
<p>具体代码其实没什么好说的，文章列表的 <code>API</code> 是 <code>/blogs</code>，而保存文章的 <code>API</code> 是 <code>/savepost</code>，删除文章的 <code>API</code> 是 <code>/deletepost</code>，获取文章列表可以用 <code>jQuery</code> 的 <code>getJSON</code> 方法，而保存和删除可以用 <code>jQuery</code> 的 <code>post</code> 方法。</p>
<p>从编辑区域获取到 <code>Markdown</code> 之后，用 <code>markdown-it</code> 渲染到右边的预览区域，并且给 <code>markdown-it</code> 添加用来生成锚点链接的 <code>markdown-it-toc</code> 和用来高亮代码的 <code>highlight.js</code> 这两个插件，然后给页面引入 <code>github-markdown</code> 这套用来渲染转化后的 <code>HTML</code> 的 <code>css</code> 以及和 <code>highlight.js</code> 配套的 <code>css</code>，差不多就完工了。</p>
<h2><a id="_Markdown__149"></a>渲染 Markdown 时的注意事项</h2>
<p>但是这里可能要注意一下原本在 <code>Node</code> 里使用的模块在引入浏览器时的用法。</p>
<p>原本作为 <code>Node</code> 模块使用的时候，先</p>
<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it'</span>);
<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highlight.js'</span>);
<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'markdown-it-toc'</span>);
</code></pre>
<p>然后</p>
<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> md = markdownIt({
  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,
  <span class="hljs-attr">xhtmlOut</span>:     <span class="hljs-literal">false</span>,
  <span class="hljs-attr">breaks</span>:       <span class="hljs-literal">false</span>,
  <span class="hljs-attr">langPrefix</span>:   <span class="hljs-string">'language-'</span>,
  <span class="hljs-attr">linkify</span>:      <span class="hljs-literal">false</span>,
  <span class="hljs-attr">typographer</span>:  <span class="hljs-literal">false</span>,
  <span class="hljs-attr">quotes</span>: <span class="hljs-string">'“”‘’'</span>,
  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{
    <span class="hljs-keyword">if</span> (lang && hljs.getLanguage(lang)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;
      } <span class="hljs-keyword">catch</span> (__) {}
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  }
});
md.use(markdownItToc);
</code></pre>
<p>就可以用来渲染 <code>Markdown</code> 了。</p>
<p>但是在浏览器里用的时候总是报错，这个对象找不到，那个对象也找不到，反正我就是没有对象就是了。</p>
<p>后来才发现，作者在写成浏览器用的版本时，暴露出来的变量名的大小写跟我引用的不一样。</p>
<p>我挨个 <code>js</code> 文件打开，发现<code>markdown-it</code> 在浏览器里的变量名是 <code>markdownit</code>，而用来生成锚点链接的 <code>markdown-it-toc</code> 的变量名是 <code>markdownitTOC</code>，于是我把自己的脚本里面的变量名改成跟原变量名一致，然后就有对象可以用了。</p>
<p>这个问题本来不应该是问题的，实在是让人懊恼。</p>
<h2><a id="_193"></a>添加页内平滑滚动效果</h2>
<p>由于文章预览区域加了锚点链接，我希望能做到禁止直接跳转 <code>#</code> 开头的锚点链接，而是平滑滚动到相关位置，这个部分的代码如下：</p>
<pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePreview</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>;
  <span class="hljs-keyword">var</span> source = $(<span class="hljs-string">"#editor"</span>).val();
  <span class="hljs-keyword">var</span> html = <span class="hljs-string">"\t"</span> + md.render(<span class="hljs-string">'[toc]\n'</span> + source);
  html = html.replace(<span class="hljs-regexp">/\&lt;a/g</span>,<span class="hljs-string">"&lt;a target='_blank'"</span>);
  $(<span class="hljs-string">"#preview"</span>).html(html);
  <span class="hljs-comment">//add scrollIntoView to anchor link</span>
  <span class="hljs-keyword">var</span> aTags = d.querySelectorAll(<span class="hljs-string">"a[href]"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; aTags.length; i++) {
    <span class="hljs-keyword">if</span> (aTags[i].href.indexOf(<span class="hljs-string">"#"</span>) !== <span class="hljs-number">-1</span>) {
      aTags[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> c = e || event;
        c.preventDefault();
        <span class="hljs-keyword">var</span> href = aTags[i].href;
        <span class="hljs-keyword">var</span> hashPos = href.indexOf(<span class="hljs-string">"#"</span>);
        <span class="hljs-keyword">var</span> id = href.substring(hashPos+<span class="hljs-number">1</span>, href.length);
        d.querySelector(<span class="hljs-string">"a[id='"</span>+<span class="hljs-built_in">String</span>(id)+<span class="hljs-string">"']"</span>).scrollIntoView({<span class="hljs-attr">behavior</span>: <span class="hljs-string">"smooth"</span>});
      }
    }
  }
}
</code></pre>
<h1><a id="_221"></a>大概是这么个效果</h1>
<p>需要访问 <code>API</code> 的时候，可以 <code>cd</code> 进入该 <code>API</code> 的文件夹，然后</p>
<pre><code>node index.js
</code></pre>
<p>再在浏览器里打开 <code>http://127.0.0.1:4000/</code> 这个页面，就能看到文章列表，可以增、删、改文章了。参考以下截图</p>
<p><img src="/img/blogs/2020-04-19/001.png" alt="preview"></p>
<h1><a id="_233"></a>心得体会</h1>
<p>今天终于把我心心念念想了一年的东西做出来了，而且只花了一天的时间，真的很开心。</p>
<p>做完之后我又研究了下，觉得这个单页面的 <code>CMS</code> 既符合 <code>基于 API 的 Headless CMS</code> 的特征，又符合 <code>Flat File CMS</code> 的特征，也就是 <code>不操作数据库而是操作文本文件的 CMS</code>，感觉好像很高级嘛~</p>
<p>而且预览区和目录区都会随着输入和保存、删除等动作自动更新，写作时无比丝滑顺畅，拿来写文档、写小说啥的好像都不错。</p>
<p>啊，我不知道怎么夸自己才好了。</p>
<p>不说这些肉麻的，总之这次写了个有用的东西，希望以后也能写出更多有用的东西。</p>
</article> <div class="prev-next"><a href="/blogs/2020-04-13-script-for-photoshop-bulk-resize-and-watermark-en" class="no-decor-link"><div class="prev"><p>上一篇</p></div></a> <a href="/blogs/2020-04-26-editor-for-my-cms-of-my-nuxt-blog-en" class="no-decor-link"><div class="next"><p>下一篇</p></div></a></div> <div><h3 style="text-align:center"><span style="border-bottom:2px solid #000">相关文章</span></h3> <div class="blog-gallery"><div class="blog-gallery-unit"><a href="/blogs/2019-05-05-set-up-static-blog-using-nuxt" title="重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>如何使用Nuxt建立个人博客</h4> <p class="blog-date"><span class="fa fa-calendar">
               2019-05-05
            </span></p> <p class="align-left"><span class="blog-gallery-desc">重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                我的项目
              </span><span class="blog-gallery-tag">
                JavaScript
              </span><span class="blog-gallery-tag">
                Nuxt
              </span><span class="blog-gallery-tag">
                静态博客
              </span></span></p></div></a></div><div class="blog-gallery-unit"><a href="/blogs/2020-01-31-a-little-summary-of-my-life-in-2019" title="我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。" class="no-decor-link"><div class="blog-gallery-inner align-left"><h4>2019年的小总结</h4> <p class="blog-date"><span class="fa fa-calendar">
               2020-01-31
            </span></p> <p class="align-left"><span class="blog-gallery-desc">我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。</span> <br> <span class="align-left"><span class="blog-gallery-tag">
                小日常
              </span><span class="blog-gallery-tag">
                剧评
              </span><span class="blog-gallery-tag">
                追星
              </span><span class="blog-gallery-tag">
                Excel
              </span><span class="blog-gallery-tag">
                JavaScript
              </span></span></p></div></a></div></div></div> <div id="comment"></div></section></div></main> <footer><p>Created with Nuxt.js <br>
    	Made by  
    	<a href="https://github.com/c53hzn" target="_blank" class="no-decor-link"><strong>Jenny HOU</strong> <i class="fa fa-github font-20"></i></a></p> <div class="go-top go-top-hidden"><div class="arrow"></div> <div class="stick"></div></div></footer></div></div></div><script>window.__NUXT__=function(s,a,n,e,l,o,c,p){return e[0]=l,e[1]=a,e[2]="Node.js",e[3]="jQuery",{layout:"page",data:[{blog:{layout:s,title:"给Nuxt使用的基于API的CMS——还有管理后台呢",description:"去年给我的Nuxt博客网站建了一个解析Markdown文件的API当做CMS，这次给API写了个管理界面，开启API就能运行，兼具Headless CMS和Flat File CMS的特征，开心~",tags:e,comments:!0,related_blog:[n,o],slug:c,content:'<p><h3> </h3><ul><li><a href="#CMS_1">一个真正的CMS</a></li><li><a href="#_19">后端需要实现的效果</a></li><li><a href="#_28">前端需要实现的效果</a></li><li><a href="#_49">后端的实际写法</a></li><ul><li><a href="#API__Markdown_51">API 被调用时直接返回未处理的 Markdown</a></li><li><a href="#_API__76">给 API 添加管理后台入口</a></li><li><a href="#_106">保存文件和删除文件</a></li></ul><li><a href="#_141">前端的实际写法</a></li><ul><li><a href="#_API__Markdown_143">调用 API 和渲染 Markdown</a></li><li><a href="#_Markdown__149">渲染 Markdown 时的注意事项</a></li><li><a href="#_193">添加页内平滑滚动效果</a></li></ul><li><a href="#_221">大概是这么个效果</a></li><li><a href="#_233">心得体会</a></li></ul></p>\n<h1><a id="CMS_1"></a>一个真正的CMS</h1>\n<p>去年开始学习使用 <code>Nuxt</code> 的时候，看了很多关于 <code>Headless CMS</code> 的介绍，按我的理解，就是 <code>不带前端页面设计的内容管理系统</code> ，研究了一下这类的项目以及相关使用方法，自己也尝试使用了一下，但是没有坚持到底，还是想不依赖这些外部服务来构建自己的网站。不过评论系统和访客统计还是得用外部服务，因为静态网站服务器做不到这些。</p>\n<p>后来我自己写出了可以用作 <code>CMS</code> 的 <code>API</code>，可以参见 <a href="/blogs/2019-05-05-set-up-static-blog-using-nuxt">这里</a>。</p>\n<p>这个 <code>API</code> 让我可以只需更新 <code>Markdown</code> 文章，再使用 <code>Nuxt</code> 的生成静态页面的功能就可以更新我的网站。通常我是用 <code>Sublime Text</code> 这个编辑器来编写代码的，它可以在左边显示工程文件，切换起来也挺方便的。</p>\n<blockquote>\n<p>可是人类就是喜欢自找麻烦。</p>\n<p>by 我</p>\n</blockquote>\n<p>我想要一个有界面的 <code>CMS</code>，能新建，能修改，能读取，能保存，能删除。但是我只要操作 <code>Markdown</code> 文件，而不要任何数据库。</p>\n<p>我觉得我能做到。</p>\n<p>写了个<a href="/blogs/2020-04-26-editor-for-my-cms-of-my-nuxt-blog-en">英文版</a>，大家随便看看就好。</p>\n<h1><a id="_19"></a>后端需要实现的效果</h1>\n<p>由于我原本的 <code>API</code> 是用 <code>Node</code> 的 <code>express</code> 写的，所以还是想在此基础上继续精进，那么就需要掌握 <code>Node</code> 服务器的一些用法，比如：</p>\n<ol>\n<li>让 <code>API</code> 读取静态 HTML 页面，使浏览器能显示 <code>CMS</code> 的 UI 界面。</li>\n<li>开启 <code>API</code> 的时候自动打开浏览器访问入口，也就是前一项的 UI 界面。</li>\n<li>让 <code>API</code> 能接受浏览器（客户端）传回来的数据，并保存到本地。</li>\n<li>让 <code>API</code> 接受浏览器传回来的数据，然后删除相关文件。</li>\n</ol>\n<h1><a id="_28"></a>前端需要实现的效果</h1>\n<p>我之前还有一个在 <a href="https://www.codepen.io">CodePen</a> 上的 <a href="https://codepen.io/c53hzn/full/YzzRzxR">Markdown Previewer</a> 的项目，半年来浏览量一只手就能数得清，就这么放着也挺可惜，不如拿来这里用一用。</p>\n<p>CodePen 项目的渲染效果是用 <code>marked</code> 来实现的的，而我的 <code>API</code> 里面是用 <code>markdown-it</code> 来做渲染的，为了统一写法，得把渲染的方式改成 <code>Markdown-it</code>。</p>\n<p>这个项目主体是用 <code>jQuery</code> 写的，我最终决定继续用 <code>jQuery</code> 来写前端的页面交互。</p>\n<p>那么我们就需要解决以下的问题：</p>\n<ol>\n<li>读取 <code>API</code> 传来的文章列表并渲染到文章列表区</li>\n<li>读取 <code>API</code> 传来的文章内容并渲染文章的标题、标签、描述、关联文章、正文到各个输入框，以及最重要的 <code>Markdown</code> 编辑器</li>\n<li>每当 <code>Markdown</code> 编辑器有更新时，预览区也要跟着更新，预览区还应该有代码高亮和一般样式渲染</li>\n<li>点击 <code>Save post</code> 的时候，页面要检查各个输入框是否都有内容，没有则 <code>alert</code> 让填写内容，有的话再检查文章是否已存在，存在则 <code>confirm</code> 要不要更新，不存在则 <code>confirm</code> 要不要创建。</li>\n<li>点击 <code>Delete post</code> 的时候，页面要检查 <code>slug</code> 在文章列表里是否存在，不存在则 <code>alert</code> 说没东西可删，如果存在则要 <code>confirm</code> 是否真的删除。</li>\n<li>键盘按下 <code>ctrl+enter</code> 触发保存，效果等同于点击 <code>Save post</code>。</li>\n<li>当确认要更新或创建的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交内容到服务器，并获取提交结果，反映到浏览器</li>\n<li>当确认要删除的时候，浏览器使用 <code>jQuery</code> 的 <code>post</code> 方法提交要删除的 <code>slug</code> 到服务器，并获取删除结果，反映到浏览器。</li>\n</ol>\n<p>并且这些要在一个页面里完成。</p>\n<h1><a id="_49"></a>后端的实际写法</h1>\n<h2><a id="API__Markdown_51"></a>API 被调用时直接返回未处理的 Markdown</h2>\n<p>首先在 <code>API</code> 的入口文件 <code>index.js</code> 里面改一下配置，这样就可以控制返回的文章正文是 <code>Markdown</code> 还是经过处理的 <code>HTML</code> 内容。</p>\n<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> singleBlog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fullPath, slug, isContentRequired, isMD</span>) </span>{\n  <span class="hljs-keyword">var</span> blog = {};\n  <span class="hljs-keyword">var</span> content = fm(fs.readFileSync(fullPath, <span class="hljs-string">"utf8"</span>));\n  blog = content.attributes;\n  blog.slug = slug;\n  <span class="hljs-keyword">if</span> (isContentRequired &amp;&amp; !isMD) {\n    blog.content = md.render(<span class="hljs-string">\'@[toc]( )\\n\'</span> + content.body);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isContentRequired &amp;&amp; isMD) {\n    blog.content = content.body;\n  }\n  <span class="hljs-keyword">return</span> blog;\n}\n\napp.get(<span class="hljs-string">"/blogs"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n  <span class="hljs-comment">//...</span>\n  <span class="hljs-keyword">var</span> qIsMD = (req.query.ismd == <span class="hljs-string">"true"</span>) || <span class="hljs-literal">false</span>;\n  <span class="hljs-comment">//...</span>\n});\n</code></pre>\n<h2><a id="_API__76"></a>给 API 添加管理后台入口</h2>\n<p>我在 <code>API</code> 所在的文件夹新建了 <code>index.html</code>，以作为 UI 界面的入口，而要让 <code>API</code> 可以访问这个静态页面，就要像下面这样写</p>\n<pre><code class="language-JavaScript"><span class="hljs-comment">//return blog content editor page</span>\napp.use(express.static(__dirname));\napp.get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{\n  <span class="hljs-comment">// allow cross orign access</span>\n  res.header(<span class="hljs-string">\'Access-Control-Allow-Origin\'</span>, <span class="hljs-string">\'*\'</span>);\n  res.sendFile(__dirname+<span class="hljs-string">"\\\\index.html"</span>);\n});\n<span class="hljs-comment">/*\n//...some other codes\n*/</span>\n<span class="hljs-comment">/* nuxt is using port 3000, so choose another one */</span>\napp.listen(<span class="hljs-number">4000</span>, () =&gt; {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"express server running at http://127.0.0.1:4000"</span>)\n});\n</code></pre>\n<p>那么这个 <code>CMS</code> 的入口链接就是 <code>http://127.0.0.1:4000/</code> 了。</p>\n<p>为了能在开启 <code>API</code> 的时候自动打开浏览器并访问该地址，还需要使用 <code>open</code> 这个 <code>npm</code>，然后加一行打开浏览器的指令</p>\n<pre><code class="language-JavaScript">open(<span class="hljs-string">"http:127.0.0.1:4000/"</span>,{<span class="hljs-attr">app</span>: <span class="hljs-string">"chrome.exe"</span>});\n</code></pre>\n<p>就能直接自动打开浏览器并访问 <code>CMS</code> 的管理界面了。这个界面总共也就一页，所以很好管理。</p>\n<h2><a id="_106"></a>保存文件和删除文件</h2>\n<p>之后就是接受浏览器传回来的数据并保存到本地，或者接收浏览器传回的删除指令，删除相关文件。</p>\n<pre><code class="language-JavaScript"><span class="hljs-comment">// save post</span>\n<span class="hljs-comment">// Parse URL-encoded bodies (as sent by HTML forms)</span>\napp.use(express.urlencoded({ <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));\n<span class="hljs-comment">// Parse JSON bodies (as sent by API clients)</span>\napp.use(express.json());\n<span class="hljs-comment">// Access the parse results as request.body</span>\napp.post(<span class="hljs-string">\'/savepost\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{\n  <span class="hljs-keyword">var</span> obj = req.body;\n  <span class="hljs-keyword">var</span> fileName = __dirname+<span class="hljs-string">"\\\\blogs\\\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;\n  fs.writeFileSync(fileName, obj.str);\n  <span class="hljs-comment">//Client will get status of failure w/o this</span>\n  <span class="hljs-comment">//even if data is saved to server successfully</span>\n  res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});\n});\n<span class="hljs-comment">// delete post</span>\napp.post(<span class="hljs-string">\'/deletepost\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{\n  <span class="hljs-keyword">var</span> obj = req.body;\n  <span class="hljs-keyword">var</span> fileName = __dirname+<span class="hljs-string">"\\\\blogs\\\\"</span>+obj.slug+<span class="hljs-string">".md"</span>;\n  <span class="hljs-keyword">try</span> {\n    fs.unlinkSync(fileName);\n    <span class="hljs-comment">//file removed</span>\n  } <span class="hljs-keyword">catch</span>(err) {\n    <span class="hljs-built_in">console</span>.error(err);\n  }\n  <span class="hljs-comment">//Client will get status of failure w/o this</span>\n  <span class="hljs-comment">//even if data is saved to server successfully</span>\n  res.send({<span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>});\n});\n</code></pre>\n<h1><a id="_141"></a>前端的实际写法</h1>\n<h2><a id="_API__Markdown_143"></a>调用 API 和渲染 Markdown</h2>\n<p>具体代码其实没什么好说的，文章列表的 <code>API</code> 是 <code>/blogs</code>，而保存文章的 <code>API</code> 是 <code>/savepost</code>，删除文章的 <code>API</code> 是 <code>/deletepost</code>，获取文章列表可以用 <code>jQuery</code> 的 <code>getJSON</code> 方法，而保存和删除可以用 <code>jQuery</code> 的 <code>post</code> 方法。</p>\n<p>从编辑区域获取到 <code>Markdown</code> 之后，用 <code>markdown-it</code> 渲染到右边的预览区域，并且给 <code>markdown-it</code> 添加用来生成锚点链接的 <code>markdown-it-toc</code> 和用来高亮代码的 <code>highlight.js</code> 这两个插件，然后给页面引入 <code>github-markdown</code> 这套用来渲染转化后的 <code>HTML</code> 的 <code>css</code> 以及和 <code>highlight.js</code> 配套的 <code>css</code>，差不多就完工了。</p>\n<h2><a id="_Markdown__149"></a>渲染 Markdown 时的注意事项</h2>\n<p>但是这里可能要注意一下原本在 <code>Node</code> 里使用的模块在引入浏览器时的用法。</p>\n<p>原本作为 <code>Node</code> 模块使用的时候，先</p>\n<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> markdownIt = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it\'</span>);\n<span class="hljs-keyword">var</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'highlight.js\'</span>);\n<span class="hljs-keyword">var</span> markdownItToc = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'markdown-it-toc\'</span>);\n</code></pre>\n<p>然后</p>\n<pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> md = markdownIt({\n  <span class="hljs-attr">html</span>:         <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">xhtmlOut</span>:     <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">breaks</span>:       <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">langPrefix</span>:   <span class="hljs-string">\'language-\'</span>,\n  <span class="hljs-attr">linkify</span>:      <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">typographer</span>:  <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">quotes</span>: <span class="hljs-string">\'“”‘’\'</span>,\n  <span class="hljs-attr">highlight</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>{\n    <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">return</span> hljs.highlight(lang, str).value;\n      } <span class="hljs-keyword">catch</span> (__) {}\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>;\n  }\n});\nmd.use(markdownItToc);\n</code></pre>\n<p>就可以用来渲染 <code>Markdown</code> 了。</p>\n<p>但是在浏览器里用的时候总是报错，这个对象找不到，那个对象也找不到，反正我就是没有对象就是了。</p>\n<p>后来才发现，作者在写成浏览器用的版本时，暴露出来的变量名的大小写跟我引用的不一样。</p>\n<p>我挨个 <code>js</code> 文件打开，发现<code>markdown-it</code> 在浏览器里的变量名是 <code>markdownit</code>，而用来生成锚点链接的 <code>markdown-it-toc</code> 的变量名是 <code>markdownitTOC</code>，于是我把自己的脚本里面的变量名改成跟原变量名一致，然后就有对象可以用了。</p>\n<p>这个问题本来不应该是问题的，实在是让人懊恼。</p>\n<h2><a id="_193"></a>添加页内平滑滚动效果</h2>\n<p>由于文章预览区域加了锚点链接，我希望能做到禁止直接跳转 <code>#</code> 开头的锚点链接，而是平滑滚动到相关位置，这个部分的代码如下：</p>\n<pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePreview</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>;\n  <span class="hljs-keyword">var</span> source = $(<span class="hljs-string">"#editor"</span>).val();\n  <span class="hljs-keyword">var</span> html = <span class="hljs-string">"\\t"</span> + md.render(<span class="hljs-string">\'[toc]\\n\'</span> + source);\n  html = html.replace(<span class="hljs-regexp">/\\&lt;a/g</span>,<span class="hljs-string">"&lt;a target=\'_blank\'"</span>);\n  $(<span class="hljs-string">"#preview"</span>).html(html);\n  <span class="hljs-comment">//add scrollIntoView to anchor link</span>\n  <span class="hljs-keyword">var</span> aTags = d.querySelectorAll(<span class="hljs-string">"a[href]"</span>);\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; aTags.length; i++) {\n    <span class="hljs-keyword">if</span> (aTags[i].href.indexOf(<span class="hljs-string">"#"</span>) !== <span class="hljs-number">-1</span>) {\n      aTags[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{\n        <span class="hljs-keyword">var</span> c = e || event;\n        c.preventDefault();\n        <span class="hljs-keyword">var</span> href = aTags[i].href;\n        <span class="hljs-keyword">var</span> hashPos = href.indexOf(<span class="hljs-string">"#"</span>);\n        <span class="hljs-keyword">var</span> id = href.substring(hashPos+<span class="hljs-number">1</span>, href.length);\n        d.querySelector(<span class="hljs-string">"a[id=\'"</span>+<span class="hljs-built_in">String</span>(id)+<span class="hljs-string">"\']"</span>).scrollIntoView({<span class="hljs-attr">behavior</span>: <span class="hljs-string">"smooth"</span>});\n      }\n    }\n  }\n}\n</code></pre>\n<h1><a id="_221"></a>大概是这么个效果</h1>\n<p>需要访问 <code>API</code> 的时候，可以 <code>cd</code> 进入该 <code>API</code> 的文件夹，然后</p>\n<pre><code>node index.js\n</code></pre>\n<p>再在浏览器里打开 <code>http://127.0.0.1:4000/</code> 这个页面，就能看到文章列表，可以增、删、改文章了。参考以下截图</p>\n<p><img src="/img/blogs/2020-04-19/001.png" alt="preview"></p>\n<h1><a id="_233"></a>心得体会</h1>\n<p>今天终于把我心心念念想了一年的东西做出来了，而且只花了一天的时间，真的很开心。</p>\n<p>做完之后我又研究了下，觉得这个单页面的 <code>CMS</code> 既符合 <code>基于 API 的 Headless CMS</code> 的特征，又符合 <code>Flat File CMS</code> 的特征，也就是 <code>不操作数据库而是操作文本文件的 CMS</code>，感觉好像很高级嘛~</p>\n<p>而且预览区和目录区都会随着输入和保存、删除等动作自动更新，写作时无比丝滑顺畅，拿来写文档、写小说啥的好像都不错。</p>\n<p>啊，我不知道怎么夸自己才好了。</p>\n<p>不说这些肉麻的，总之这次写了个有用的东西，希望以后也能写出更多有用的东西。</p>\n',prev:"2020-04-13-script-for-photoshop-bulk-resize-and-watermark-en",next:"2020-04-26-editor-for-my-cms-of-my-nuxt-blog-en"},tags:e,date:"2020-04-19",relatedBlog:[{layout:s,title:"如何使用Nuxt建立个人博客",description:"重构了一下博客，从Jekyll迁移到了Nuxt。方法是先用Node API 来解析 Markdown 文件，然后 Nuxt+Axios 获取 API 返回的文章内容并生成静态页面。",tags:[l,a,"Nuxt","静态博客"],comments:!0,related_blog:["2018-03-28-set-up-static-blog",p,c],slug:n,prev:"2018-12-21-Korean-drama-memories-of-the-alhambra-n-feel-good-to-die",next:p,date:"2019-05-05"},{layout:s,title:"2019年的小总结",description:"我的2019年过得还算充实，看了很多剧，追了很多星，做了很多事，还学了很多东西，要继续保持。",tags:["小日常","剧评","追星","Excel",a],comments:!0,related_blog:["2019-08-17-tv-drama-the-birth-of-the-drama-king",n,"2020-02-13-tv-drama-die-now"],slug:o,prev:"2019-12-28-why-vlookup-cannot-return-value",next:"2020-02-01-memories-about-plagues",date:"2020-01-31"}],baseURL:"/",ui_str:{to_prev:"上一篇",to_next:"下一篇",related_posts:"相关文章"}}],fetch:[],error:null,serverRendered:!0,routePath:"/blogs/2020-04-19-editor-for-my-cms-of-my-nuxt-blog"}}("post","JavaScript","2019-05-05-set-up-static-blog-using-nuxt",Array(4),"我的项目","2020-01-31-a-little-summary-of-my-life-in-2019","2020-04-19-editor-for-my-cms-of-my-nuxt-blog","2019-05-18-lighten-nuxt-generated-site-by-removing-marked-and-highlightjs")</script><script src="/_nuxt/2d31f6c0bf5b6a854bae.js" defer></script><script src="/_nuxt/adb15844b8ba2f434984.js" defer></script><script src="/_nuxt/275bef93b4559841d52d.js" defer></script><script src="/_nuxt/c69520ae9fda1118c222.js" defer></script>
  </body>
</html>
